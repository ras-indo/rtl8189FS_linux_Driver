./Makefile:1283:ccflags-y += -DCONFIG_P2P_IPS -DCONFIG_PLATFORM_ANDROID
./Makefile:1861:ccflags-y += -DRTW_P2P_GROUP_INTERFACE=1
./Makefile:2017:ccflags-y += -DCONFIG_CONCURRENT_MODE -DCONFIG_FULL_CH_IN_P2P_HANDSHAKE
./Makefile:2040:#ccflags-y += -DCONFIG_P2P_IPS -DCONFIG_QOS_OPTIMIZATION
./Makefile:2051:ccflags-y += -DRTW_P2P_GROUP_INTERFACE=1
./core/efuse/rtw_efuse.c:3191:		wl_func |= WL_FUNC_P2P;
./core/rtw_ap.c:25:extern unsigned char	P2P_OUI[];
./core/rtw_ap.c:1987:#ifdef CONFIG_P2P
./core/rtw_ap.c:3194:	else if (_rtw_memcmp(P2P_OUI, oui, 4))
./core/rtw_beamforming.c:64:		 * 1. Sent to an IBSS STA
./core/rtw_beamforming.c:350:	 * STA that is a member of an IBSS
./core/rtw_cmd.c:868:#ifdef CONFIG_P2P_PS
./core/rtw_cmd.c:870:		p2p_ps_wk_cmd(padapter, P2P_PS_SCAN, 1);
./core/rtw_cmd.c:871:#endif /* CONFIG_P2P_PS */
./core/rtw_cmd.c:1395:		case Ndis802_11IBSS:
./core/rtw_cmd.c:3769:#ifdef CONFIG_P2P
./core/rtw_cmd.c:3779:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_cmd.c:3795:	pdrvextra_cmd_parm->ec_id = P2P_PROTO_WK_CID;
./core/rtw_cmd.c:3843:		if (H2C_SUCCESS != p2p_protocol_wk_hdl(adapter, cancel ? P2P_CANCEL_RO_CH_WK : P2P_RO_CH_WK, (u8 *)roch_parm))
./core/rtw_cmd.c:3855:		parm->ec_id = P2P_PROTO_WK_CID;
./core/rtw_cmd.c:3856:		parm->type = cancel ? P2P_CANCEL_RO_CH_WK : P2P_RO_CH_WK;
./core/rtw_cmd.c:3908:#endif /* CONFIG_P2P */
./core/rtw_cmd.c:5577:#ifdef CONFIG_P2P_PS
./core/rtw_cmd.c:5578:	case P2P_PS_WK_CID:
./core/rtw_cmd.c:5582:#ifdef CONFIG_P2P
./core/rtw_cmd.c:5583:	case P2P_PROTO_WK_CID:
./core/rtw_debug.c:512:#ifdef CONFIG_P2P
./core/rtw_debug.c:513:#define P2P_INFO_TITLE_FMT	" %-3s %-4s"
./core/rtw_debug.c:514:#define P2P_INFO_TITLE_ARG	, "lch", "p2ps"
./core/rtw_debug.c:516:#define P2P_INFO_VALUE_FMT	" %3u %c%3u"
./core/rtw_debug.c:517:#define P2P_INFO_VALUE_ARG	, iface->wdinfo.listen_channel, iface->wdev_data.p2p_enabled ? 'e' : ' ', rtw_p2p_state(&iface->wdinfo)
./core/rtw_debug.c:519:#define P2P_INFO_VALUE_FMT	" %3u %4u"
./core/rtw_debug.c:520:#define P2P_INFO_VALUE_ARG	, iface->wdinfo.listen_channel, rtw_p2p_state(&iface->wdinfo)
./core/rtw_debug.c:522:#define P2P_INFO_DASH		"---------"
./core/rtw_debug.c:524:#define P2P_INFO_TITLE_FMT	""
./core/rtw_debug.c:525:#define P2P_INFO_TITLE_ARG
./core/rtw_debug.c:526:#define P2P_INFO_VALUE_FMT	""
./core/rtw_debug.c:527:#define P2P_INFO_VALUE_ARG
./core/rtw_debug.c:528:#define P2P_INFO_DASH
./core/rtw_debug.c:556:		P2P_INFO_TITLE_FMT
./core/rtw_debug.c:560:		P2P_INFO_TITLE_ARG
./core/rtw_debug.c:565:		P2P_INFO_DASH
./core/rtw_debug.c:612:				P2P_INFO_VALUE_FMT
./core/rtw_debug.c:625:				P2P_INFO_VALUE_ARG
./core/rtw_debug.c:634:		P2P_INFO_DASH
./core/rtw_debug.c:1569:			(pnetwork->network.InfrastructureMode == Ndis802_11IBSS) ? "[IBSS]" :
./core/rtw_debug.c:1572:			(ie_p2p) ? "[P2P]" : "");
./core/rtw_debug.c:4835:#ifdef CONFIG_P2P_WOWLAN
./core/rtw_debug.c:4845:		case P2P_WOWLAN_RECV_NEGO_REQ:
./core/rtw_debug.c:4848:		case P2P_WOWLAN_RECV_INVITE_REQ:
./core/rtw_debug.c:4851:		case P2P_WOWLAN_RECV_PROVISION_REQ:
./core/rtw_debug.c:4865:#endif /* CONFIG_P2P_WOWLAN */
./core/rtw_ieee80211.c:530:	*(u16 *)ie |= cpu_to_le16(cap_IBSS);
./core/rtw_ieee80211.c:572:	/* IBSS Parameter Set */
./core/rtw_ieee80211.c:574:	ie = rtw_set_ie(ie, _IBSS_PARA_IE_, 2, (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
./core/rtw_ieee80211.c:1325:		case WLAN_EID_IBSS_PARAMS:
./core/rtw_ieee80211.c:1705:#ifdef CONFIG_P2P
./core/rtw_ieee80211.c:1938:			len += pIE->Length - 4; /* 4 is P2P OUI length, don't count it in this loop */
./core/rtw_ieee80211.c:1944:	return len + 4;	/* Append P2P OUI length at last. */
./core/rtw_ieee80211.c:1963:		/* Set first P2P OUI */
./core/rtw_ieee80211.c:1970:			/* Take out the rest of P2P OUIs */
./core/rtw_ieee80211.c:1980:		return len + 4;	/* 4 is for P2P OUI */
./core/rtw_ieee80211.c:2013: * rtw_get_p2p_ie - Search P2P IE from a series of IEs
./core/rtw_ieee80211.c:2016: * @p2p_ie: If not NULL and P2P IE is found, P2P IE will be copied to the buf starting from p2p_ie
./core/rtw_ieee80211.c:2017: * @p2p_ielen: If not NULL and P2P IE is found, will set to the length of the entire P2P IE
./core/rtw_ieee80211.c:2019: * Returns: The address of the P2P IE found, or NULL
./core/rtw_ieee80211.c:2067: * rtw_get_p2p_attr - Search a specific P2P attribute from a given P2P IE
./core/rtw_ieee80211.c:2068: * @p2p_ie: Address of P2P IE to search
./core/rtw_ieee80211.c:2070: * @target_attr_id: The attribute ID of P2P attribute to search
./core/rtw_ieee80211.c:2071: * @buf_attr: If not NULL and the P2P attribute is found, P2P attribute will be copied to the buf starting from buf_attr
./core/rtw_ieee80211.c:2072: * @len_attr: If not NULL and the P2P attribute is found, will set to the length of the entire P2P attribute
./core/rtw_ieee80211.c:2124: * rtw_get_p2p_attr_content - Search a specific P2P attribute content from a given P2P IE
./core/rtw_ieee80211.c:2125: * @p2p_ie: Address of P2P IE to search
./core/rtw_ieee80211.c:2127: * @target_attr_id: The attribute ID of P2P attribute to search
./core/rtw_ieee80211.c:2128: * @buf_content: If not NULL and the P2P attribute is found, P2P attribute content will be copied to the buf starting from buf_content
./core/rtw_ieee80211.c:2129: * @len_content: If not NULL and the P2P attribute is found, will set to the length of the P2P attribute content
./core/rtw_ieee80211.c:2131: * Returns: the address of the specific P2P attribute content found, or NULL
./core/rtw_ieee80211.c:2175:#define DBG_DEL_P2P_IE 0
./core/rtw_ieee80211.c:2188:			if (DBG_DEL_P2P_IE && msg) {
./core/rtw_ieee80211.c:2201:			if (DBG_DEL_P2P_IE && msg) {
./core/rtw_ieee80211.c:2216:#define DBG_DEL_P2P_ATTR 0
./core/rtw_ieee80211.c:2229:			if (DBG_DEL_P2P_ATTR) {
./core/rtw_ieee80211.c:2243:			if (DBG_DEL_P2P_ATTR) {
./core/rtw_ieee80211.c:2263:#define DBG_BSS_EX_DEL_P2P_IE 0
./core/rtw_ieee80211.c:2269:	ies_len = rtw_del_p2p_ie(ies, ies_len_ori, DBG_BSS_EX_DEL_P2P_IE ? __func__ : NULL);
./core/rtw_ieee80211.c:2275:#define DBG_BSS_EX_DEL_P2P_ATTR 0
./core/rtw_ieee80211.c:2292:			if (DBG_BSS_EX_DEL_P2P_ATTR) {
./core/rtw_ieee80211.c:2316:			if (DBG_BSS_EX_DEL_P2P_ATTR) {
./core/rtw_ieee80211.c:2363: * Returns: The address of the P2P IE found, or NULL
./core/rtw_ieee80211.c:2908:	case RTW_WLAN_CATEGORY_P2P: /* vendor-specific */
./core/rtw_ioctl_set.c:468:		if ((is_linked == _TRUE) || (*pold_state == Ndis802_11IBSS))
./core/rtw_ioctl_set.c:475:		if ((*pold_state == Ndis802_11Infrastructure) || (*pold_state == Ndis802_11IBSS)) {
./core/rtw_ioctl_set.c:490:		case Ndis802_11IBSS:
./core/rtw_mi.c:31:#ifdef CONFIG_P2P
./core/rtw_mi.c:41:		if (rtw_p2p_chk_state(&iface->wdinfo, P2P_STATE_LISTEN) ||
./core/rtw_mi.c:42:			rtw_p2p_chk_state(&iface->wdinfo, P2P_STATE_SCAN)) {
./core/rtw_mi.c:74:		#ifdef CONFIG_P2P
./core/rtw_mi.c:76:			RTW_ERR("P2P in listen or scan state\n");
./core/rtw_mi.c:208:				#ifdef CONFIG_P2P
./core/rtw_mi.c:210:					MSTATE_P2P_GC_NUM(mstate)++;
./core/rtw_mi.c:222:				#ifdef CONFIG_P2P
./core/rtw_mi.c:224:					MSTATE_P2P_GO_NUM(mstate)++;
./core/rtw_mi.c:262:		#ifdef CONFIG_P2P
./core/rtw_mi.c:267:#ifdef CONFIG_P2P
./core/rtw_mi.c:269:			MSTATE_P2P_DV_NUM(mstate)++;
./core/rtw_mi.c:312:	#ifdef CONFIG_P2P
./core/rtw_mi.c:339:#ifdef CONFIG_P2P
./core/rtw_mi.c:340:	RTW_PRINT_SEL(sel, "p2p_device_num:%d\n", DEV_P2P_DV_NUM(dvobj));
./core/rtw_mi.c:341:	RTW_PRINT_SEL(sel, "p2p_gc_num:%d\n", DEV_P2P_GC_NUM(dvobj));
./core/rtw_mi.c:342:	RTW_PRINT_SEL(sel, "p2p_go_num:%d\n", DEV_P2P_GO_NUM(dvobj));
./core/rtw_mi.c:347:	#if defined(CONFIG_P2P)
./core/rtw_mi.c:1222:#ifdef CONFIG_P2P
./core/rtw_mi.c:1226:	enum P2P_STATE state = *(enum P2P_STATE *)data;
./core/rtw_mi.c:1230:u8 rtw_mi_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state)
./core/rtw_mi.c:1236:u8 rtw_mi_buddy_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state)
./core/rtw_mi.c:1246:	if (rtw_p2p_role(pwdinfo) != P2P_ROLE_DISABLE)
./core/rtw_mi.c:1258:#endif /*CONFIG_P2P*/
./core/rtw_mlme.c:695:#ifdef CONFIG_P2P
./core/rtw_mlme.c:696:	if ((feature == 1) && /* 1: P2P supported */
./core/rtw_mlme.c:718:		((s_cap & WLAN_CAPABILITY_IBSS) == (d_cap & WLAN_CAPABILITY_IBSS)) &&
./core/rtw_mlme.c:945:#ifdef CONFIG_P2P
./core/rtw_mlme.c:947:#endif /* CONFIG_P2P */
./core/rtw_mlme.c:964:#ifdef CONFIG_P2P
./core/rtw_mlme.c:965:	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_mlme.c:977:#ifdef CONFIG_P2P
./core/rtw_mlme.c:978:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
./core/rtw_mlme.c:1170:#if defined(CONFIG_P2P) && defined(CONFIG_P2P_REMOVE_GROUP_INFO)
./core/rtw_mlme.c:1172:		rtw_bss_ex_del_p2p_attr(pnetwork, P2P_ATTR_GROUP_INFO);
./core/rtw_mlme.c:1273:	/* update IBSS_network 's timestamp */
./core/rtw_mlme.c:1431:#ifdef CONFIG_P2P_PS
./core/rtw_mlme.c:1433:		p2p_ps_wk_cmd(adapter, P2P_PS_SCAN_DONE, 0);
./core/rtw_mlme.c:1434:#endif /* CONFIG_P2P_PS */
./core/rtw_mlme.c:1735:#ifdef CONFIG_P2P
./core/rtw_mlme.c:1736:			if (!rtw_p2p_chk_state(&adapter->wdinfo, P2P_STATE_NONE)) {
./core/rtw_mlme.c:1740:#endif /* CONFIG_P2P */
./core/rtw_mlme.c:1854:#ifdef CONFIG_P2P_PS
./core/rtw_mlme.c:1855:	p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
./core/rtw_mlme.c:1856:#endif /* CONFIG_P2P_PS */
./core/rtw_mlme.c:2170:	case Ndis802_11IBSS:
./core/rtw_mlme.c:3257:#ifdef CONFIG_P2P
./core/rtw_mlme.c:3258:	if (!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE))
./core/rtw_mlme.c:4405:	if (cur_network->network.InfrastructureMode == Ndis802_11IBSS) {
./core/rtw_mlme_ext.c:94:	{RTW_WLAN_CATEGORY_P2P, "ACTION_P2P", &OnAction_p2p},
./core/rtw_mlme_ext.c:106:unsigned char	P2P_OUI[] = {0x50, 0x6F, 0x9A, 0x09};
./core/rtw_mlme_ext.c:1407:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:1447:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:1477:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:1484:	    && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
./core/rtw_mlme_ext.c:1492:	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
./core/rtw_mlme_ext.c:1493:	    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE) &&
./core/rtw_mlme_ext.c:1494:	    !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) &&
./core/rtw_mlme_ext.c:1495:	    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH) &&
./core/rtw_mlme_ext.c:1496:	    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN)
./core/rtw_mlme_ext.c:1503:		/*	In the P2P mode, the driver should not support the CCK rate */
./core/rtw_mlme_ext.c:1515:				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE)) {
./core/rtw_mlme_ext.c:1525:				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
./core/rtw_mlme_ext.c:1532:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:1721:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:1726:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:1727:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
./core/rtw_mlme_ext.c:1730:				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
./core/rtw_mlme_ext.c:1736:				} else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:1746:	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING)) {
./core/rtw_mlme_ext.c:1748:			RTW_INFO("[%s] P2P State is GONEGO ING!\n", __FUNCTION__);
./core/rtw_mlme_ext.c:1754:	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ)) {
./core/rtw_mlme_ext.c:1756:			RTW_INFO("[%s] P2P_STATE_TX_INVITE_REQ!\n", __FUNCTION__);
./core/rtw_mlme_ext.c:1935:#ifdef CONFIG_P2P_PS
./core/rtw_mlme_ext.c:1936:			/* Comment by YiWei , in wifi p2p spec the "3.3 P2P Power Management" , "These mechanisms are available in a P2P Group in which only P2P Devices are associated." */
./core/rtw_mlme_ext.c:1938:#endif /* CONFIG_P2P_PS */
./core/rtw_mlme_ext.c:1940:#if defined(CONFIG_P2P) && defined(CONFIG_CONCURRENT_MODE)
./core/rtw_mlme_ext.c:1944:						RTW_PRINT("no issue auth, P2P cross-connect does not permit\n ");
./core/rtw_mlme_ext.c:1949:#endif /* CONFIG_P2P CONFIG_P2P and CONFIG_CONCURRENT_MODE */
./core/rtw_mlme_ext.c:2014:#ifdef CONFIG_P2P_PS
./core/rtw_mlme_ext.c:2016:#endif /* CONFIG_P2P_PS */
./core/rtw_mlme_ext.c:2440:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:2442:	u8 p2p_status_code = P2P_STATUS_SUCCESS;
./core/rtw_mlme_ext.c:2445:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:2588:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:2590:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:2606:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:2833:#if defined(CONFIG_P2P) && defined(CONFIG_WFD)
./core/rtw_mlme_ext.c:2935:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:2937:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:2945:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:2950:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:3023:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:3025:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:3033:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:3038:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:3730:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:3746:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_mlme_ext.c:3747:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_mlme_ext.c:3748:	u8			oui_subtype = P2P_GO_NEGO_REQ;
./core/rtw_mlme_ext.c:3832:	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN)
./core/rtw_mlme_ext.c:3834:	else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN)
./core/rtw_mlme_ext.c:3836:	else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC)
./core/rtw_mlme_ext.c:3844:	/*	P2P IE Section. */
./core/rtw_mlme_ext.c:3846:	/*	P2P OUI */
./core/rtw_mlme_ext.c:3851:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_mlme_ext.c:3854:	/*	According to the P2P Specification, the group negoitation request frame should contain 9 P2P attributes */
./core/rtw_mlme_ext.c:3855:	/*	1. P2P Capability */
./core/rtw_mlme_ext.c:3860:	/*	6. Intended P2P Interface Address */
./core/rtw_mlme_ext.c:3862:	/*	8. P2P Device Info */
./core/rtw_mlme_ext.c:3866:	/*	P2P Capability */
./core/rtw_mlme_ext.c:3868:	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./core/rtw_mlme_ext.c:3876:	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./core/rtw_mlme_ext.c:3880:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
./core/rtw_mlme_ext.c:3882:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
./core/rtw_mlme_ext.c:3887:	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
./core/rtw_mlme_ext.c:3899:	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
./core/rtw_mlme_ext.c:3906:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P GO */
./core/rtw_mlme_ext.c:3907:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P Client */
./core/rtw_mlme_ext.c:3912:	p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
./core/rtw_mlme_ext.c:3936:	p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
./core/rtw_mlme_ext.c:3952:	/*	Intended P2P Interface Address */
./core/rtw_mlme_ext.c:3954:	p2pie[p2pielen++] = P2P_ATTR_INTENDED_IF_ADDR;
./core/rtw_mlme_ext.c:3967:	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
./core/rtw_mlme_ext.c:4039:	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./core/rtw_mlme_ext.c:4042:	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./core/rtw_mlme_ext.c:4048:	/*	P2P Device Address */
./core/rtw_mlme_ext.c:4053:	/*	This field should be big endian. Noted by P2P specification. */
./core/rtw_mlme_ext.c:4091:	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./core/rtw_mlme_ext.c:4142:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_mlme_ext.c:4143:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_mlme_ext.c:4144:	u8			oui_subtype = P2P_GO_NEGO_RESP;
./core/rtw_mlme_ext.c:4261:	/*	P2P IE Section. */
./core/rtw_mlme_ext.c:4263:	/*	P2P OUI */
./core/rtw_mlme_ext.c:4268:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_mlme_ext.c:4271:	/*	According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes */
./core/rtw_mlme_ext.c:4273:	/*	2. P2P Capability */
./core/rtw_mlme_ext.c:4277:	/*	6. Intended P2P Interface Address */
./core/rtw_mlme_ext.c:4285:	/*	P2P Status */
./core/rtw_mlme_ext.c:4287:	p2pie[p2pielen++] = P2P_ATTR_STATUS;
./core/rtw_mlme_ext.c:4296:	/*	P2P Capability */
./core/rtw_mlme_ext.c:4298:	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./core/rtw_mlme_ext.c:4307:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
./core/rtw_mlme_ext.c:4309:		/*	According to the P2P specification */
./core/rtw_mlme_ext.c:4310:		/*	if the sending device will be client, the P2P Capability should be reserved of group negotation response frame */
./core/rtw_mlme_ext.c:4314:		p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./core/rtw_mlme_ext.c:4319:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
./core/rtw_mlme_ext.c:4321:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
./core/rtw_mlme_ext.c:4325:	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
./core/rtw_mlme_ext.c:4343:	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
./core/rtw_mlme_ext.c:4350:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P GO */
./core/rtw_mlme_ext.c:4351:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P Client */
./core/rtw_mlme_ext.c:4355:	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./core/rtw_mlme_ext.c:4385:	/*	Intended P2P Interface Address	 */
./core/rtw_mlme_ext.c:4387:	p2pie[p2pielen++] = P2P_ATTR_INTENDED_IF_ADDR;
./core/rtw_mlme_ext.c:4399:	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
./core/rtw_mlme_ext.c:4470:	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./core/rtw_mlme_ext.c:4473:	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./core/rtw_mlme_ext.c:4479:	/*	P2P Device Address */
./core/rtw_mlme_ext.c:4484:	/*	This field should be big endian. Noted by P2P specification. */
./core/rtw_mlme_ext.c:4519:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:4522:		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
./core/rtw_mlme_ext.c:4559:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_mlme_ext.c:4560:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_mlme_ext.c:4561:	u8			oui_subtype = P2P_GO_NEGO_CONF;
./core/rtw_mlme_ext.c:4613:	/*	P2P IE Section. */
./core/rtw_mlme_ext.c:4615:	/*	P2P OUI */
./core/rtw_mlme_ext.c:4620:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_mlme_ext.c:4623:	/*	According to the P2P Specification, the group negoitation request frame should contain 5 P2P attributes */
./core/rtw_mlme_ext.c:4625:	/*	2. P2P Capability */
./core/rtw_mlme_ext.c:4630:	/*	P2P Status */
./core/rtw_mlme_ext.c:4632:	p2pie[p2pielen++] = P2P_ATTR_STATUS;
./core/rtw_mlme_ext.c:4641:	/*	P2P Capability */
./core/rtw_mlme_ext.c:4643:	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./core/rtw_mlme_ext.c:4651:	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./core/rtw_mlme_ext.c:4655:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
./core/rtw_mlme_ext.c:4657:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
./core/rtw_mlme_ext.c:4662:	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./core/rtw_mlme_ext.c:4678:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
./core/rtw_mlme_ext.c:4710:	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
./core/rtw_mlme_ext.c:4724:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
./core/rtw_mlme_ext.c:4754:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:4757:		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
./core/rtw_mlme_ext.c:4793:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_mlme_ext.c:4794:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_mlme_ext.c:4795:	u8			oui_subtype = P2P_INVIT_REQ;
./core/rtw_mlme_ext.c:4847:	/*	P2P IE Section. */
./core/rtw_mlme_ext.c:4849:	/*	P2P OUI */
./core/rtw_mlme_ext.c:4854:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_mlme_ext.c:4857:	/*	According to the P2P Specification, the P2P Invitation request frame should contain 7 P2P attributes */
./core/rtw_mlme_ext.c:4861:	/*	4. P2P Group BSSID	( Should be included if I am the GO ) */
./core/rtw_mlme_ext.c:4863:	/*	6. P2P Group ID */
./core/rtw_mlme_ext.c:4864:	/*	7. P2P Device Info */
./core/rtw_mlme_ext.c:4868:	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
./core/rtw_mlme_ext.c:4875:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P GO */
./core/rtw_mlme_ext.c:4876:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P Client */
./core/rtw_mlme_ext.c:4880:	p2pie[p2pielen++] = P2P_ATTR_INVITATION_FLAGS;
./core/rtw_mlme_ext.c:4887:	p2pie[p2pielen++] = P2P_INVITATION_FLAGS_PERSISTENT;
./core/rtw_mlme_ext.c:4892:	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./core/rtw_mlme_ext.c:4919:		/*	P2P Group BSSID */
./core/rtw_mlme_ext.c:4921:		p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
./core/rtw_mlme_ext.c:4928:		/*	P2P Device Address for GO */
./core/rtw_mlme_ext.c:4935:	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
./core/rtw_mlme_ext.c:5004:	/*	P2P Group ID */
./core/rtw_mlme_ext.c:5006:	p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
./core/rtw_mlme_ext.c:5013:	/*	P2P Device Address for GO */
./core/rtw_mlme_ext.c:5024:	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./core/rtw_mlme_ext.c:5027:	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./core/rtw_mlme_ext.c:5033:	/*	P2P Device Address */
./core/rtw_mlme_ext.c:5038:	/*	This field should be big endian. Noted by P2P specification. */
./core/rtw_mlme_ext.c:5091:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_mlme_ext.c:5092:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_mlme_ext.c:5093:	u8			oui_subtype = P2P_INVIT_RESP;
./core/rtw_mlme_ext.c:5144:	/*	P2P IE Section. */
./core/rtw_mlme_ext.c:5146:	/*	P2P OUI */
./core/rtw_mlme_ext.c:5151:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_mlme_ext.c:5154:	/*	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes */
./core/rtw_mlme_ext.c:5158:	/*	4. P2P Group BSSID	( Only GO ) */
./core/rtw_mlme_ext.c:5161:	/*	P2P Status */
./core/rtw_mlme_ext.c:5163:	p2pie[p2pielen++] = P2P_ATTR_STATUS;
./core/rtw_mlme_ext.c:5170:	/*	When status code is P2P_STATUS_FAIL_INFO_UNAVAILABLE. */
./core/rtw_mlme_ext.c:5171:	/*	Sent the event receiving the P2P Invitation Req frame to DMP UI. */
./core/rtw_mlme_ext.c:5173:	/*	So, the WiFi driver will send the P2P_STATUS_FAIL_INFO_UNAVAILABLE to NB. */
./core/rtw_mlme_ext.c:5174:	/*	If the UI found the corresponding profile, the WiFi driver sends the P2P Invitation Req */
./core/rtw_mlme_ext.c:5180:	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
./core/rtw_mlme_ext.c:5187:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P GO */
./core/rtw_mlme_ext.c:5188:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P Client */
./core/rtw_mlme_ext.c:5190:	if (status_code == P2P_STATUS_SUCCESS) {
./core/rtw_mlme_ext.c:5191:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:5192:			/*	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO */
./core/rtw_mlme_ext.c:5193:			/*	In this case, the P2P Invitation response frame should carry the two more P2P attributes. */
./core/rtw_mlme_ext.c:5195:			/*	Second one is P2P Group BSSID attribute. */
./core/rtw_mlme_ext.c:5199:			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./core/rtw_mlme_ext.c:5221:			/*	P2P Group BSSID */
./core/rtw_mlme_ext.c:5223:			p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
./core/rtw_mlme_ext.c:5230:			/*	P2P Device Address for GO */
./core/rtw_mlme_ext.c:5238:		p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
./core/rtw_mlme_ext.c:5325:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_mlme_ext.c:5327:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_mlme_ext.c:5328:	u8			oui_subtype = P2P_PROVISION_DISC_REQ;
./core/rtw_mlme_ext.c:5440:	for (i = 0; i < P2P_MAX_PERSISTENT_GROUP_NUM; i++, profileinfo++) {
./core/rtw_mlme_ext.c:5523:	/*	ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec) */
./core/rtw_mlme_ext.c:5536:	/*	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 ) */
./core/rtw_mlme_ext.c:5550:			/* P2P IE */
./core/rtw_mlme_ext.c:5737:	pattrib->pktlen += rtw_build_vendor_ie(padapter , &pframe , WIFI_P2P_PROBERESP_VENDOR_IE_BIT);
./core/rtw_mlme_ext.c:5800:			/*	This two flags will be set when this is only the P2P client mode. */
./core/rtw_mlme_ext.c:5818:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
./core/rtw_mlme_ext.c:5821:		pframe = rtw_set_ie(pframe, _SSID_IE_, P2P_WILDCARD_SSID_LEN, pwdinfo->p2p_wildcard_ssid, &(pattrib->pktlen));
./core/rtw_mlme_ext.c:5822:	/*	Use the OFDM rate in the P2P probe request frame. ( 6(B), 9(B), 12(B), 24(B), 36, 48, 54 ) */
./core/rtw_mlme_ext.c:5833:			/* P2P IE */
./core/rtw_mlme_ext.c:5945:		/*	P2P OUI */
./core/rtw_mlme_ext.c:5950:		p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_mlme_ext.c:5953:		/*	According to the P2P Specification, the probe request frame should contain 5 P2P attributes */
./core/rtw_mlme_ext.c:5954:		/*	1. P2P Capability */
./core/rtw_mlme_ext.c:5955:		/*	2. P2P Device ID if this probe request wants to find the specific P2P device */
./core/rtw_mlme_ext.c:5960:		/*	P2P Capability */
./core/rtw_mlme_ext.c:5962:		p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./core/rtw_mlme_ext.c:5970:		p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./core/rtw_mlme_ext.c:5974:			p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_mlme_ext.c:5976:			p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_mlme_ext.c:5980:		p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
./core/rtw_mlme_ext.c:6004:		p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
./core/rtw_mlme_ext.c:6019:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:6022:			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./core/rtw_mlme_ext.c:6057:	pattrib->pktlen += rtw_build_vendor_ie(padapter , &pframe , WIFI_P2P_PROBEREQ_VENDOR_IE_BIT);
./core/rtw_mlme_ext.c:6124:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:6157:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:6161:	u8	result = P2P_STATUS_SUCCESS;
./core/rtw_mlme_ext.c:6165:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:6169:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:6177:		/*	Do nothing if the driver doesn't enable the P2P function. */
./core/rtw_mlme_ext.c:6178:		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
./core/rtw_mlme_ext.c:6184:		case P2P_GO_NEGO_REQ: {
./core/rtw_mlme_ext.c:6188:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
./core/rtw_mlme_ext.c:6191:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL)) {
./core/rtw_mlme_ext.c:6206:			if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
./core/rtw_mlme_ext.c:6218:			/*	No matter negotiating or negotiation failure, the driver should set up the restore P2P state timer. */
./core/rtw_mlme_ext.c:6227:		case P2P_GO_NEGO_RESP: {
./core/rtw_mlme_ext.c:6230:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING)) {
./core/rtw_mlme_ext.c:6237:				if (P2P_STATUS_SUCCESS == result) {
./core/rtw_mlme_ext.c:6238:					if (rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT) {
./core/rtw_mlme_ext.c:6240:#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
./core/rtw_mlme_ext.c:6244:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./core/rtw_mlme_ext.c:6246:						_set_timer(&pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
./core/rtw_mlme_ext.c:6253:				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
./core/rtw_mlme_ext.c:6256:				RTW_INFO("[%s] Skipped GO Nego Resp Frame (p2p_state != P2P_STATE_GONEGO_ING)\n", __FUNCTION__);
./core/rtw_mlme_ext.c:6260:		case P2P_GO_NEGO_CONF: {
./core/rtw_mlme_ext.c:6263:			if (P2P_STATUS_SUCCESS == result) {
./core/rtw_mlme_ext.c:6264:				if (rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT) {
./core/rtw_mlme_ext.c:6266:#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
./core/rtw_mlme_ext.c:6270:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./core/rtw_mlme_ext.c:6272:					_set_timer(&pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
./core/rtw_mlme_ext.c:6277:		case P2P_INVIT_REQ: {
./core/rtw_mlme_ext.c:6279:			/*	Received the P2P Invite Request frame. */
./core/rtw_mlme_ext.c:6284:				/*	Parse the necessary information from the P2P Invitation Request frame. */
./core/rtw_mlme_ext.c:6285:				/*	For example: The MAC address of sending this P2P Invitation Request frame. */
./core/rtw_mlme_ext.c:6287:				u8	status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./core/rtw_mlme_ext.c:6302:				rtw_get_p2p_attr_content(merged_p2pie, merged_p2p_ielen, P2P_ATTR_INVITATION_FLAGS, &invitation_flag, &attr_contentlen);
./core/rtw_mlme_ext.c:6305:					rtw_get_p2p_attr_content(merged_p2pie, merged_p2p_ielen, P2P_ATTR_GROUP_BSSID, pwdinfo->p2p_peer_interface_addr, &attr_contentlen);
./core/rtw_mlme_ext.c:6319:					if (invitation_flag & P2P_INVITATION_FLAGS_PERSISTENT) {
./core/rtw_mlme_ext.c:6323:						rtw_get_p2p_attr_content(merged_p2pie, merged_p2p_ielen, P2P_ATTR_GROUP_ID, (u8 *) &group_id, &attr_contentlen);
./core/rtw_mlme_ext.c:6327:								rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_GO);
./core/rtw_mlme_ext.c:6328:								rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_mlme_ext.c:6329:								status_code = P2P_STATUS_SUCCESS;
./core/rtw_mlme_ext.c:6334:									if (rtw_get_p2p_attr_content(merged_p2pie, merged_p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info,
./core/rtw_mlme_ext.c:6339:#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
./core/rtw_mlme_ext.c:6343:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./core/rtw_mlme_ext.c:6345:											_set_timer(&pwdinfo->reset_ch_sitesurvey, P2P_RESET_SCAN_CH);
./core/rtw_mlme_ext.c:6346:											rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH);
./core/rtw_mlme_ext.c:6347:											rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_mlme_ext.c:6348:											status_code = P2P_STATUS_SUCCESS;
./core/rtw_mlme_ext.c:6351:											rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
./core/rtw_mlme_ext.c:6352:											rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_mlme_ext.c:6353:											status_code = P2P_STATUS_FAIL_NO_COMMON_CH;
./core/rtw_mlme_ext.c:6358:										/*	Intel will use the different P2P IE to store the operating channel information */
./core/rtw_mlme_ext.c:6360:										rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH);
./core/rtw_mlme_ext.c:6361:										rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_mlme_ext.c:6362:										status_code = P2P_STATUS_SUCCESS;
./core/rtw_mlme_ext.c:6365:									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
./core/rtw_mlme_ext.c:6366:									status_code = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
./core/rtw_mlme_ext.c:6370:							RTW_INFO("[%s] P2P Group ID Attribute NOT FOUND!\n", __FUNCTION__);
./core/rtw_mlme_ext.c:6371:							status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./core/rtw_mlme_ext.c:6374:						/*	Received the invitation to join a P2P group. */
./core/rtw_mlme_ext.c:6377:						rtw_get_p2p_attr_content(merged_p2pie, merged_p2p_ielen, P2P_ATTR_GROUP_ID, (u8 *) &group_id, &attr_contentlen);
./core/rtw_mlme_ext.c:6381:								rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
./core/rtw_mlme_ext.c:6382:								status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./core/rtw_mlme_ext.c:6384:								/*	The p2p device sending this p2p invitation request wants to join an existing P2P group */
./core/rtw_mlme_ext.c:6391:								rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_mlme_ext.c:6392:								rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_JOIN);
./core/rtw_mlme_ext.c:6393:								status_code = P2P_STATUS_SUCCESS;
./core/rtw_mlme_ext.c:6396:							RTW_INFO("[%s] P2P Group ID Attribute NOT FOUND!\n", __FUNCTION__);
./core/rtw_mlme_ext.c:6397:							status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./core/rtw_mlme_ext.c:6401:					RTW_INFO("[%s] P2P Invitation Flags Attribute NOT FOUND!\n", __FUNCTION__);
./core/rtw_mlme_ext.c:6402:					status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./core/rtw_mlme_ext.c:6413:		case P2P_INVIT_RESP: {
./core/rtw_mlme_ext.c:6421:				rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
./core/rtw_mlme_ext.c:6427:					if (attr_content == P2P_STATUS_SUCCESS) {
./core/rtw_mlme_ext.c:6429:							rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_mlme_ext.c:6431:							rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_mlme_ext.c:6433:						rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_OK);
./core/rtw_mlme_ext.c:6435:						rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_mlme_ext.c:6436:						rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL);
./core/rtw_mlme_ext.c:6439:					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_mlme_ext.c:6440:					rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL);
./core/rtw_mlme_ext.c:6443:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_mlme_ext.c:6444:				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL);
./core/rtw_mlme_ext.c:6447:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL))
./core/rtw_mlme_ext.c:6451:		case P2P_DEVDISC_REQ:
./core/rtw_mlme_ext.c:6457:		case P2P_DEVDISC_RESP:
./core/rtw_mlme_ext.c:6463:		case P2P_PROVISION_DISC_REQ:
./core/rtw_mlme_ext.c:6470:			if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
./core/rtw_mlme_ext.c:6473:			rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
./core/rtw_mlme_ext.c:6474:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
./core/rtw_mlme_ext.c:6477:		case P2P_PROVISION_DISC_RESP:
./core/rtw_mlme_ext.c:6484:			rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP);
./core/rtw_mlme_ext.c:6486:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
./core/rtw_mlme_ext.c:6497:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:6507:	if (_rtw_memcmp(frame_body + 2, P2P_OUI, 4) == _TRUE) {
./core/rtw_mlme_ext.c:7295:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:7309:	if (category != RTW_WLAN_CATEGORY_P2P)
./core/rtw_mlme_ext.c:7312:	if (cpu_to_be32(*((u32 *)(frame_body + 1))) != P2POUI)
./core/rtw_mlme_ext.c:7329:		case P2P_NOTICE_OF_ABSENCE:
./core/rtw_mlme_ext.c:7333:		case P2P_PRESENCE_REQUEST:
./core/rtw_mlme_ext.c:7339:		case P2P_PRESENCE_RESPONSE:
./core/rtw_mlme_ext.c:7343:		case P2P_GO_DISC_REQUEST:
./core/rtw_mlme_ext.c:7352:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:7515:#ifdef CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./core/rtw_mlme_ext.c:7517:#endif /* CONFIG_P2P_PS_NOA_USE_MACID_SLEEP */
./core/rtw_mlme_ext.c:7532:#ifdef CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./core/rtw_mlme_ext.c:7537:			if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
./core/rtw_mlme_ext.c:7550:					if (pwdinfo->p2p_ps_state != P2P_PS_DISABLE)
./core/rtw_mlme_ext.c:7555:#endif /* CONFIG_P2P_PS_NOA_USE_MACID_SLEEP */
./core/rtw_mlme_ext.c:7741:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:7743:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:7799:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:7800:		/* for P2P : Primary Device Type & Device Name */
./core/rtw_mlme_ext.c:7805:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && wpsie && wpsielen > 0) {
./core/rtw_mlme_ext.c:7894:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:7927:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:7928:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:7954:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:8004:		/* IBSS Parameter Set... */
./core/rtw_mlme_ext.c:8007:		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
./core/rtw_mlme_ext.c:8064:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:8066:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:8226:			/* IBSS Parameter Set... */
./core/rtw_mlme_ext.c:8229:			pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
./core/rtw_mlme_ext.c:8251:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:8252:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
./core/rtw_mlme_ext.c:8253:	    /* IOT issue, When wifi_spec is not set, send probe_resp with P2P IE even if probe_req has no P2P IE */
./core/rtw_mlme_ext.c:8258:			/* if pwdinfo->role == P2P_ROLE_DEVICE will call issue_probersp_p2p() */
./core/rtw_mlme_ext.c:8281:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:8689:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:8695:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:8859:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:8860:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && (pstat->is_p2p_device == _TRUE)) {
./core/rtw_mlme_ext.c:8876:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_mlme_ext.c:8883:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:8918:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:8925:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:9188:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:9200:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {
./core/rtw_mlme_ext.c:9201:			/*	Should add the P2P IE in the association request frame.	 */
./core/rtw_mlme_ext.c:9202:			/*	P2P OUI */
./core/rtw_mlme_ext.c:9208:			p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_mlme_ext.c:9211:			/*	According to the P2P Specification, the association request frame should contain 3 P2P attributes */
./core/rtw_mlme_ext.c:9212:			/*	1. P2P Capability */
./core/rtw_mlme_ext.c:9216:			/*	4. P2P Interface */
./core/rtw_mlme_ext.c:9218:			/*	P2P Capability */
./core/rtw_mlme_ext.c:9220:			p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./core/rtw_mlme_ext.c:9228:			p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./core/rtw_mlme_ext.c:9232:				p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_mlme_ext.c:9234:				p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_mlme_ext.c:9238:			p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
./core/rtw_mlme_ext.c:9255:			p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./core/rtw_mlme_ext.c:9258:			/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./core/rtw_mlme_ext.c:9264:			/*	P2P Device Address */
./core/rtw_mlme_ext.c:9269:			/*	This field should be big endian. Noted by P2P specification. */
./core/rtw_mlme_ext.c:9270:			if ((pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) ||
./core/rtw_mlme_ext.c:9271:			    (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN))
./core/rtw_mlme_ext.c:9307:			/*	P2P Interface */
./core/rtw_mlme_ext.c:9309:			p2pie[p2pielen++] = P2P_ATTR_INTERFACE;
./core/rtw_mlme_ext.c:9316:			_rtw_memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/*	P2P Device Address */
./core/rtw_mlme_ext.c:9319:			p2pie[p2pielen++] = 1;	/*	P2P Interface Address Count */
./core/rtw_mlme_ext.c:9321:			_rtw_memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/*	P2P Interface Address List */
./core/rtw_mlme_ext.c:9333:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:9684:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:9686:#endif /* CONFIG_P2P	 */
./core/rtw_mlme_ext.c:9690:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:9691:	if (!(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) && (pwdinfo->rx_invitereq_info.scan_op_ch_only)) {
./core/rtw_mlme_ext.c:9695:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:10957:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:10967:			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, listen_ch, &attr_contentlen);
./core/rtw_mlme_ext.c:10981:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:11015:	} else if ((val16 & 0x03) == cap_IBSS){
./core/rtw_mlme_ext.c:11016:		bssid->InfrastructureMode = Ndis802_11IBSS;
./core/rtw_mlme_ext.c:11052:			bssid->InfrastructureMode = Ndis802_11IBSS;
./core/rtw_mlme_ext.c:11124:	if (caps & cap_IBSS) { /* adhoc master */
./core/rtw_mlme_ext.c:11213:		/*	For the Win8 P2P connection, it will be hard to have a successful connection if this Wi-Fi doesn't connect to it. */
./core/rtw_mlme_ext.c:11215:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:11243:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:11265:	} else if (caps & cap_IBSS) { /* adhoc client */
./core/rtw_mlme_ext.c:12005:		ADPT_ARG(if_port0), if_port0_mlmeinfo->state, rtw_p2p_state(&if_port0->wdinfo), rtw_p2p_chk_state(&if_port0->wdinfo, P2P_STATE_NONE),
./core/rtw_mlme_ext.c:12006:		ADPT_ARG(if_port1), if_port1_mlmeinfo->state, rtw_p2p_state(&if_port1->wdinfo), rtw_p2p_chk_state(&if_port1->wdinfo, P2P_STATE_NONE));
./core/rtw_mlme_ext.c:12030:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:12031:	    && !rtw_p2p_chk_state(&if_port1->wdinfo, P2P_STATE_NONE)
./core/rtw_mlme_ext.c:12441:	if (is_client_associated_to_ap(padapter) || is_IBSS_empty(padapter))
./core/rtw_mlme_ext.c:12745:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:12746:		if (!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE)) {
./core/rtw_mlme_ext.c:12752:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:12774:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:12775:			is_p2p_enable = !rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE);
./core/rtw_mlme_ext.c:13734:	} else if (psetop->mode == Ndis802_11IBSS)
./core/rtw_mlme_ext.c:13802:		rtw_warn_on(pdev_network->InfrastructureMode != Ndis802_11IBSS);
./core/rtw_mlme_ext.c:14085:	"SCAN_TO_P2P_LISTEN",
./core/rtw_mlme_ext.c:14086:	"SCAN_P2P_LISTEN",
./core/rtw_mlme_ext.c:14101:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14107:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14108:		if (!rtw_p2p_chk_state(&adapter->wdinfo, P2P_STATE_NONE)) {
./core/rtw_mlme_ext.c:14109:			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_MAX);
./core/rtw_mlme_ext.c:14429:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14439:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14458:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:14524:		next_state = SCAN_TO_P2P_LISTEN;
./core/rtw_mlme_ext.c:14584:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14599:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14603:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN)
./core/rtw_mlme_ext.c:14604:				|| rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH))
./core/rtw_mlme_ext.c:14611:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:14669:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14684:			if (rtw_p2p_chk_state(&iface->wdinfo, P2P_STATE_LISTEN)) {
./core/rtw_mlme_ext.c:14694:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:14812:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14818:		#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:14824:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_mlme_ext.c:14827:		#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:14847:	case SCAN_TO_P2P_LISTEN:
./core/rtw_mlme_ext.c:14933:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:15050:			#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:15072:			#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:15229:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:15230:	case SCAN_TO_P2P_LISTEN:
./core/rtw_mlme_ext.c:15232:		* Set the P2P State to the listen state of find phase
./core/rtw_mlme_ext.c:15236:		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_LISTEN);
./core/rtw_mlme_ext.c:15243:		mlmeext_set_scan_state(pmlmeext, SCAN_P2P_LISTEN);
./core/rtw_mlme_ext.c:15247:	case SCAN_P2P_LISTEN:
./core/rtw_mlme_ext.c:15251:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:15257:#ifdef CONFIG_P2P
./core/rtw_mlme_ext.c:15258:		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN)
./core/rtw_mlme_ext.c:15259:		    || rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH)
./core/rtw_mlme_ext.c:15270:		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
./core/rtw_mlme_ext.c:15271:#endif /* CONFIG_P2P */
./core/rtw_mlme_ext.c:16171:#if defined(CONFIG_P2P)
./core/rtw_mlme_ext.c:16172:			    && rtw_p2p_chk_state(&(iface->wdinfo), P2P_STATE_NONE)
./core/rtw_mp.c:816:		bssid.InfrastructureMode = Ndis802_11IBSS;
./core/rtw_p2p.c:15:#define _RTW_P2P_C_
./core/rtw_p2p.c:19:#ifdef CONFIG_P2P
./core/rtw_p2p.c:52:	pdata_attr = rtw_zmalloc(MAX_P2P_IE_LEN);
./core/rtw_p2p.c:78:			/* P2P device address */
./core/rtw_p2p.c:82:			/* P2P interface address */
./core/rtw_p2p.c:132:		len = rtw_set_p2p_attr_content(pbuf, P2P_ATTR_GROUP_INFO, attr_len, pdata_attr);
./core/rtw_p2p.c:134:	rtw_mfree(pdata_attr, MAX_P2P_IE_LEN);
./core/rtw_p2p.c:151:	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame	 */
./core/rtw_p2p.c:152:	u32	p2poui = cpu_to_be32(P2POUI);
./core/rtw_p2p.c:153:	u8	oui_subtype = P2P_GO_DISC_REQUEST;
./core/rtw_p2p.c:185:	/* Build P2P action frame header */
./core/rtw_p2p.c:191:	/* there is no IE in this P2P action frame */
./core/rtw_p2p.c:210:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_p2p.c:211:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_p2p.c:212:	u8			oui_subtype = P2P_DEVDISC_RESP;
./core/rtw_p2p.c:245:	/* Build P2P public action frame header */
./core/rtw_p2p.c:253:	/* Build P2P IE */
./core/rtw_p2p.c:254:	/*	P2P OUI */
./core/rtw_p2p.c:259:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_p2p.c:261:	/* P2P_ATTR_STATUS */
./core/rtw_p2p.c:262:	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
./core/rtw_p2p.c:276:	u8			action = P2P_PUB_ACTION_ACTION;
./core/rtw_p2p.c:278:	u32			p2poui = cpu_to_be32(P2POUI);
./core/rtw_p2p.c:279:	u8			oui_subtype = P2P_PROVISION_DISC_RESP;
./core/rtw_p2p.c:390:	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame	 */
./core/rtw_p2p.c:391:	u32	p2poui = cpu_to_be32(P2POUI);
./core/rtw_p2p.c:392:	u8	oui_subtype = P2P_PRESENCE_RESPONSE;
./core/rtw_p2p.c:393:	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
./core/rtw_p2p.c:426:	/* Build P2P action frame header */
./core/rtw_p2p.c:433:	/* Add P2P IE header */
./core/rtw_p2p.c:434:	/*	P2P OUI */
./core/rtw_p2p.c:439:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_p2p.c:441:	/* Add Status attribute in P2P IE */
./core/rtw_p2p.c:442:	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
./core/rtw_p2p.c:444:	/* Add NoA attribute in P2P IE */
./core/rtw_p2p.c:450:	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_NOA, 2, noa_attr_content);
./core/rtw_p2p.c:465:	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
./core/rtw_p2p.c:470:	/*	P2P OUI */
./core/rtw_p2p.c:475:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_p2p.c:478:	/*	According to the P2P Specification, the beacon frame should contain 3 P2P attributes */
./core/rtw_p2p.c:479:	/*	1. P2P Capability */
./core/rtw_p2p.c:480:	/*	2. P2P Device ID */
./core/rtw_p2p.c:483:	/*	P2P Capability ATTR */
./core/rtw_p2p.c:488:	/*	Be able to participate in additional P2P Groups and */
./core/rtw_p2p.c:489:	/*	support the P2P Invitation Procedure	 */
./core/rtw_p2p.c:491:	capability = P2P_DEVCAP_INVITATION_PROC | P2P_DEVCAP_CLIENT_DISCOVERABILITY;
./core/rtw_p2p.c:492:	capability |= ((P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS) << 8);
./core/rtw_p2p.c:493:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
./core/rtw_p2p.c:494:		capability |= (P2P_GRPCAP_GROUP_FORMATION << 8);
./core/rtw_p2p.c:498:	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (u8 *)&capability);
./core/rtw_p2p.c:501:	/* P2P Device ID ATTR */
./core/rtw_p2p.c:502:	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_DEVICE_ID, ETH_ALEN, pwdinfo->device_addr);
./core/rtw_p2p.c:559:	if (P2P_ROLE_GO == pwdinfo->role) {
./core/rtw_p2p.c:788:		if (P2P_ROLE_GO == pwdinfo->role) {
./core/rtw_p2p.c:884:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:954:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
./core/rtw_p2p.c:1535:	if (P2P_ROLE_GO == pwdinfo->role) {
./core/rtw_p2p.c:1648:	if (P2P_ROLE_GO == pwdinfo->role) {
./core/rtw_p2p.c:1870:	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
./core/rtw_p2p.c:1873:	/*	P2P OUI */
./core/rtw_p2p.c:1878:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_p2p.c:1881:	/*	According to the P2P Specification, the probe response frame should contain 5 P2P attributes */
./core/rtw_p2p.c:1882:	/*	1. P2P Capability */
./core/rtw_p2p.c:1888:	/*	P2P Capability ATTR */
./core/rtw_p2p.c:1890:	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./core/rtw_p2p.c:1899:	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./core/rtw_p2p.c:1902:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:1903:		p2pie[p2pielen] = (P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS);
./core/rtw_p2p.c:1905:		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
./core/rtw_p2p.c:1906:			p2pie[p2pielen] |= P2P_GRPCAP_GROUP_FORMATION;
./core/rtw_p2p.c:1909:	} else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE)) {
./core/rtw_p2p.c:1912:			p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_p2p.c:1914:			p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_p2p.c:1919:	p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
./core/rtw_p2p.c:1942:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:1948:	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./core/rtw_p2p.c:1951:	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./core/rtw_p2p.c:1958:	/*	P2P Device Address */
./core/rtw_p2p.c:1963:	/*	This field should be big endian. Noted by P2P specification. */
./core/rtw_p2p.c:2008:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
./core/rtw_p2p.c:2021:	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
./core/rtw_p2p.c:2024:	/*	P2P OUI */
./core/rtw_p2p.c:2029:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_p2p.c:2032:	/*	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
./core/rtw_p2p.c:2033:	/*	1. P2P Capability */
./core/rtw_p2p.c:2035:	/*	3. Group ID ( When joining an operating P2P Group ) */
./core/rtw_p2p.c:2037:	/*	P2P Capability ATTR */
./core/rtw_p2p.c:2039:	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./core/rtw_p2p.c:2048:	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./core/rtw_p2p.c:2052:		p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_p2p.c:2054:		p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
./core/rtw_p2p.c:2059:	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./core/rtw_p2p.c:2062:	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./core/rtw_p2p.c:2069:	/*	P2P Device Address */
./core/rtw_p2p.c:2074:	/*	This field should be big endian. Noted by P2P specification. */
./core/rtw_p2p.c:2075:	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC) {
./core/rtw_p2p.c:2119:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
./core/rtw_p2p.c:2123:		/*	P2P Group ID ATTR */
./core/rtw_p2p.c:2125:		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
./core/rtw_p2p.c:2151:	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
./core/rtw_p2p.c:2154:	/*	P2P OUI */
./core/rtw_p2p.c:2159:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./core/rtw_p2p.c:2161:	/* According to the P2P Specification, the Association response frame should contain 2 P2P attributes */
./core/rtw_p2p.c:2167:	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status_code);
./core/rtw_p2p.c:2223:	/*	1. This probe request frame must contain the P2P IE. (Done) */
./core/rtw_p2p.c:2228:	/*	6. Device ID attribute in P2P IE. (Todo) */
./core/rtw_p2p.c:2234:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:2240:				/* Check Device ID attribute in P2P IE */
./core/rtw_p2p.c:2258:	u8 status_code = P2P_STATUS_SUCCESS;
./core/rtw_p2p.c:2268:	if (!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
./core/rtw_p2p.c:2269:		return P2P_STATUS_FAIL_REQUEST_UNABLE;
./core/rtw_p2p.c:2283:		RTW_INFO("[%s] P2P IE not Found!!\n", __FUNCTION__);
./core/rtw_p2p.c:2284:		status_code =  P2P_STATUS_FAIL_INVALID_PARAM;
./core/rtw_p2p.c:2286:		RTW_INFO("[%s] P2P IE Found!!\n", __FUNCTION__);
./core/rtw_p2p.c:2289:		/* Check P2P Capability ATTR */
./core/rtw_p2p.c:2290:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&cap_attr, (uint *) &attr_contentlen)) {
./core/rtw_p2p.c:2291:			RTW_INFO("[%s] Got P2P Capability Attr!!\n", __FUNCTION__);
./core/rtw_p2p.c:2299:		/* Check P2P Device Info ATTR */
./core/rtw_p2p.c:2300:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint *)&attr_contentlen)) {
./core/rtw_p2p.c:2301:			RTW_INFO("[%s] Got P2P DEVICE INFO Attr!!\n", __FUNCTION__);
./core/rtw_p2p.c:2308:				rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO , pattr_content, (uint *)&attr_contentlen);
./core/rtw_p2p.c:2310:				_rtw_memcpy(psta->dev_addr, 	pattr_content, ETH_ALEN);/* P2P Device Address */
./core/rtw_p2p.c:2357:		/* Get the next P2P IE */
./core/rtw_p2p.c:2379:	status = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
./core/rtw_p2p.c:2387:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen)) {
./core/rtw_p2p.c:2391:				if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_ID, dev_addr, &attr_contentlen)) {
./core/rtw_p2p.c:2405:						if (psta->is_p2p_device && (psta->dev_cap & P2P_DEVCAP_CLIENT_DISCOVERABILITY) &&
./core/rtw_p2p.c:2413:							status = P2P_STATUS_SUCCESS;
./core/rtw_p2p.c:2417:							status = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./core/rtw_p2p.c:2423:					status = P2P_STATUS_FAIL_INVALID_PARAM;
./core/rtw_p2p.c:2426:				status = P2P_STATUS_FAIL_INVALID_PARAM;
./core/rtw_p2p.c:2437:	return (status == P2P_STATUS_SUCCESS) ? _TRUE : _FALSE;
./core/rtw_p2p.c:2536:	u8	result = P2P_STATUS_SUCCESS;
./core/rtw_p2p.c:2567:		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
./core/rtw_p2p.c:2568:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2578:		RTW_INFO("[%s] P2P IE not Found!!\n", __FUNCTION__);
./core/rtw_p2p.c:2579:		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
./core/rtw_p2p.c:2580:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2595:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
./core/rtw_p2p.c:2597:		/* Check P2P Capability ATTR */
./core/rtw_p2p.c:2598:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&cap_attr, (uint *)&attr_contentlen)) {
./core/rtw_p2p.c:2602:			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
./core/rtw_p2p.c:2607:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen)) {
./core/rtw_p2p.c:2613:				if (pwdinfo->intent == P2P_MAX_INTENT) {
./core/rtw_p2p.c:2614:					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_p2p.c:2615:					result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
./core/rtw_p2p.c:2618:						rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_p2p.c:2620:						rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_p2p.c:2623:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_p2p.c:2625:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_p2p.c:2627:			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:2634:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, (u8 *)listen_ch_attr, (uint *) &attr_contentlen) && attr_contentlen == 5)
./core/rtw_p2p.c:2640:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENDED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen)) {
./core/rtw_p2p.c:2645:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, ch_content, &ch_cnt)) {
./core/rtw_p2p.c:2651:				result = P2P_STATUS_FAIL_NO_COMMON_CH;
./core/rtw_p2p.c:2652:				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2656:			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:2663:						result = P2P_STATUS_FAIL_NO_COMMON_CH;
./core/rtw_p2p.c:2664:						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2672:						if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
./core/rtw_p2p.c:2693:		/* Get the next P2P IE */
./core/rtw_p2p.c:2697:	if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO) {
./core/rtw_p2p.c:2698:		result = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./core/rtw_p2p.c:2699:		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INFOR_NOREADY);
./core/rtw_p2p.c:2713:	u8	result = P2P_STATUS_SUCCESS;
./core/rtw_p2p.c:2727:	/*	Be able to know which one is the P2P GO and which one is P2P client. */
./core/rtw_p2p.c:2733:		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
./core/rtw_p2p.c:2734:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2739:		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_p2p.c:2740:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2741:		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
./core/rtw_p2p.c:2754:		while (p2p_ie) {	/*	Found the P2P IE. */
./core/rtw_p2p.c:2756:			/* Check P2P Capability ATTR */
./core/rtw_p2p.c:2757:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&cap_attr, (uint *)&attr_contentlen)) {
./core/rtw_p2p.c:2760:				if (!(cap_attr & P2P_GRPCAP_INTRABSS))
./core/rtw_p2p.c:2765:			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
./core/rtw_p2p.c:2768:				if (attr_content == P2P_STATUS_SUCCESS) {
./core/rtw_p2p.c:2771:					if (P2P_STATUS_FAIL_INFO_UNAVAILABLE == attr_content)
./core/rtw_p2p.c:2772:						rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INFOR_NOREADY);
./core/rtw_p2p.c:2774:						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2775:					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_p2p.c:2783:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENDED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen)) {
./core/rtw_p2p.c:2791:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen)) {
./core/rtw_p2p.c:2797:					if (pwdinfo->intent == P2P_MAX_INTENT) {
./core/rtw_p2p.c:2798:						rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_p2p.c:2799:						result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
./core/rtw_p2p.c:2800:						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2802:						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2803:						rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2805:							rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_p2p.c:2807:							rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_p2p.c:2810:					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2811:					rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2812:					rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_p2p.c:2814:					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2815:					rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2816:					rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_p2p.c:2819:				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:2830:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen)) {
./core/rtw_p2p.c:2836:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, pwdinfo->channel_list_attr, &pwdinfo->channel_list_attr_len)) {
./core/rtw_p2p.c:2844:					result = P2P_STATUS_FAIL_NO_COMMON_CH;
./core/rtw_p2p.c:2845:					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2849:				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./core/rtw_p2p.c:2856:							result = P2P_STATUS_FAIL_NO_COMMON_CH;
./core/rtw_p2p.c:2857:							rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2865:							if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
./core/rtw_p2p.c:2891:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen)) {
./core/rtw_p2p.c:2896:			/* Get the next P2P IE */
./core/rtw_p2p.c:2919:	u8	result = P2P_STATUS_SUCCESS;
./core/rtw_p2p.c:2924:	while (p2p_ie) {	/*	Found the P2P IE. */
./core/rtw_p2p.c:2930:		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
./core/rtw_p2p.c:2935:			if (attr_content == P2P_STATUS_SUCCESS) {
./core/rtw_p2p.c:2941:				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2942:				rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:2944:					rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_p2p.c:2946:					rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_p2p.c:2950:						rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_p2p.c:2952:						rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_p2p.c:2963:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_p2p.c:2964:				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
./core/rtw_p2p.c:2972:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen)) {
./core/rtw_p2p.c:2979:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen)) {
./core/rtw_p2p.c:2984:		/* Get the next P2P IE */
./core/rtw_p2p.c:2996:	u8 status = P2P_STATUS_SUCCESS;
./core/rtw_p2p.c:3019:	_rtw_memcpy(&parm.ssid[0].Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
./core/rtw_p2p.c:3020:	parm.ssid[0].SsidLength = P2P_WILDCARD_SSID_LEN;
./core/rtw_p2p.c:3023:	rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
./core/rtw_p2p.c:3038:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
./core/rtw_p2p.c:3039:		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_p2p.c:3047:		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP)) {
./core/rtw_p2p.c:3056:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE)) {
./core/rtw_p2p.c:3060:		/*	In the P2P client mode, the driver should not switch back to its listen channel */
./core/rtw_p2p.c:3061:		/*	because this P2P client should stay at the operating channel of P2P GO. */
./core/rtw_p2p.c:3075:	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./core/rtw_p2p.c:3087:	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./core/rtw_p2p.c:3101:	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./core/rtw_p2p.c:3133:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {
./core/rtw_p2p.c:3135:				/*	If the pwdinfo->ext_listen_period = 0, that means the P2P listen state is not available on listen channel. */
./core/rtw_p2p.c:3137:					RTW_INFO("[%s] P2P_STATE_IDLE, ext_listen_period = %d\n", __FUNCTION__, pwdinfo->ext_listen_period);
./core/rtw_p2p.c:3144:					rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
./core/rtw_p2p.c:3154:			} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) ||
./core/rtw_p2p.c:3155:				rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL) ||
./core/rtw_p2p.c:3156:				(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == _FALSE) ||
./core/rtw_p2p.c:3157:				rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ)) {
./core/rtw_p2p.c:3158:				/*	Now, the driver is in the listen state of P2P mode. */
./core/rtw_p2p.c:3159:				RTW_INFO("[%s] P2P_STATE_IDLE, ext_listen_interval = %d\n", __FUNCTION__, pwdinfo->ext_listen_interval);
./core/rtw_p2p.c:3163:				/*	Other P2P device is still able to find this device out even this device is in the AP's channel. */
./core/rtw_p2p.c:3172:					rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
./core/rtw_p2p.c:3179:			} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK)) {
./core/rtw_p2p.c:3180:				/*	The driver had finished the P2P handshake successfully. */
./core/rtw_p2p.c:3186:			} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
./core/rtw_p2p.c:3191:				_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./core/rtw_p2p.c:3192:			} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == _TRUE) {
./core/rtw_p2p.c:3197:				_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./core/rtw_p2p.c:3198:			} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ) && pwdinfo->invitereq_info.benable == _TRUE) {
./core/rtw_p2p.c:3204:				_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
./core/rtw_p2p.c:3209:		/* In p2p+softap. When in P2P_STATE_GONEGO_OK, not back to listen channel.*/
./core/rtw_p2p.c:3210:		if (!rtw_p2p_chk_state(pwdinfo , P2P_STATE_GONEGO_OK) || padapter->registrypriv.full_ch_in_p2p_handshake == 0)
./core/rtw_p2p.c:3465:		/* Check P2P_ATTR_OPERATING_CH */
./core/rtw_p2p.c:3468:		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint *)&attr_contentlen);
./core/rtw_p2p.c:3472:		/* Get the next P2P IE */
./core/rtw_p2p.c:3498:		/* Check P2P_ATTR_CH_LIST */
./core/rtw_p2p.c:3499:		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint *)&attr_contentlen);
./core/rtw_p2p.c:3518:		/* Get the next P2P IE */
./core/rtw_p2p.c:3541:		/* Check P2P_ATTR_CH_LIST */
./core/rtw_p2p.c:3542:		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint *)&attr_contentlen);
./core/rtw_p2p.c:3566:		/* Get the next P2P IE */
./core/rtw_p2p.c:3573:#if defined(CONFIG_P2P_INVITE_IOT)
./core/rtw_p2p.c:3590:		/* Check P2P_ATTR_OPERATING_CH */
./core/rtw_p2p.c:3593:		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint *)&attr_contentlen);
./core/rtw_p2p.c:3602:		/* Get the next P2P IE */
./core/rtw_p2p.c:3630:		/* Check P2P_ATTR_CH_LIST */
./core/rtw_p2p.c:3631:		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint *)&attr_contentlen);
./core/rtw_p2p.c:3656:		/* Check P2P_ATTR_OPERATING_CH */
./core/rtw_p2p.c:3659:		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint *)&attr_contentlen);
./core/rtw_p2p.c:3669:		/* Get the next P2P IE */
./core/rtw_p2p.c:3692:		    && _rtw_memcmp(frame_body + 2, P2P_OUI, 4) == _TRUE
./core/rtw_p2p.c:3698:			case P2P_GO_NEGO_REQ:
./core/rtw_p2p.c:3701:			case P2P_GO_NEGO_RESP:
./core/rtw_p2p.c:3704:			case P2P_GO_NEGO_CONF:
./core/rtw_p2p.c:3707:			case P2P_INVIT_REQ:
./core/rtw_p2p.c:3710:			case P2P_INVIT_RESP:
./core/rtw_p2p.c:3713:			case P2P_PROVISION_DISC_REQ:
./core/rtw_p2p.c:3716:			case P2P_PROVISION_DISC_RESP:
./core/rtw_p2p.c:3719:			case P2P_DEVDISC_REQ:
./core/rtw_p2p.c:3720:			case P2P_DEVDISC_RESP:
./core/rtw_p2p.c:3726:	} else if (category == RTW_WLAN_CATEGORY_P2P) {
./core/rtw_p2p.c:3731:		RTW_INFO("ACTION_CATEGORY_P2P: OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n"
./core/rtw_p2p.c:3736:		case P2P_NOTICE_OF_ABSENCE:
./core/rtw_p2p.c:3738:		case P2P_PRESENCE_REQUEST:
./core/rtw_p2p.c:3740:		case P2P_PRESENCE_RESPONSE:
./core/rtw_p2p.c:3742:		case P2P_GO_DISC_REQUEST:
./core/rtw_p2p.c:3771:		    && _rtw_memcmp(frame_body + 2, P2P_OUI, 4) == _TRUE
./core/rtw_p2p.c:3776:			case P2P_GO_NEGO_REQ:
./core/rtw_p2p.c:3777:			case P2P_GO_NEGO_RESP:
./core/rtw_p2p.c:3778:			case P2P_GO_NEGO_CONF:
./core/rtw_p2p.c:3779:			case P2P_INVIT_REQ:
./core/rtw_p2p.c:3780:			case P2P_INVIT_RESP:
./core/rtw_p2p.c:3781:			case P2P_PROVISION_DISC_REQ:
./core/rtw_p2p.c:3782:			case P2P_PROVISION_DISC_RESP:
./core/rtw_p2p.c:3836:	pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, &attr_contentlen);
./core/rtw_p2p.c:3912:			&& _rtw_memcmp(frame_body + 2, P2P_OUI, 4) == _TRUE
./core/rtw_p2p.c:3931:			case P2P_GO_NEGO_REQ: {
./core/rtw_p2p.c:3948:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len);
./core/rtw_p2p.c:3951:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, NULL, &cont_len);
./core/rtw_p2p.c:3954:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT, NULL, &cont_len);
./core/rtw_p2p.c:3957:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENDED_IF_ADDR, NULL, &cont_len);
./core/rtw_p2p.c:3975:				RTW_INFO("RTW_%s:P2P_GO_NEGO_REQ, dialogToken=%d, intent:%u%s, listen_ch:%d, op_ch:%d, ch_list:%s"
./core/rtw_p2p.c:3994:			case P2P_GO_NEGO_RESP: {
./core/rtw_p2p.c:4004:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len);
./core/rtw_p2p.c:4007:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT, NULL, &cont_len);
./core/rtw_p2p.c:4010:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
./core/rtw_p2p.c:4013:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENDED_IF_ADDR, NULL, &cont_len);
./core/rtw_p2p.c:4031:				RTW_INFO("RTW_%s:P2P_GO_NEGO_RESP, dialogToken=%d, intent:%u%s, status:%d, op_ch:%d, ch_list:%s"
./core/rtw_p2p.c:4051:			case P2P_GO_NEGO_CONF: {
./core/rtw_p2p.c:4062:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len);
./core/rtw_p2p.c:4065:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
./core/rtw_p2p.c:4085:				RTW_INFO("RTW_%s:P2P_GO_NEGO_CONF, dialogToken=%d, status:%d, op_ch:%d, ch_list:%s\n"
./core/rtw_p2p.c:4093:			case P2P_INVIT_REQ: {
./core/rtw_p2p.c:4105:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INVITATION_FLAGS, NULL, &cont_len);
./core/rtw_p2p.c:4108:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len);
./core/rtw_p2p.c:4111:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_BSSID, NULL, &cont_len);
./core/rtw_p2p.c:4128:				RTW_INFO("RTW_%s:P2P_INVIT_REQ, dialogToken=%d, flags:0x%02x, op_ch:%d, ch_list:%s"
./core/rtw_p2p.c:4137:						#if defined(CONFIG_P2P_INVITE_IOT)
./core/rtw_p2p.c:4153:			case P2P_INVIT_RESP: {
./core/rtw_p2p.c:4163:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
./core/rtw_p2p.c:4165:					#ifdef CONFIG_P2P_INVITE_IOT
./core/rtw_p2p.c:4167:						RTW_INFO("TX_P2P_INVITE_RESP, status is no common channel, change to unknown group\n");
./core/rtw_p2p.c:4170:					#endif /* CONFIG_P2P_INVITE_IOT */
./core/rtw_p2p.c:4173:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len);
./core/rtw_p2p.c:4176:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_BSSID, NULL, &cont_len);
./core/rtw_p2p.c:4190:				RTW_INFO("RTW_%s:P2P_INVIT_RESP, dialogToken=%d, status:%d, op_ch:%d, ch_list:%s"
./core/rtw_p2p.c:4201:			case P2P_DEVDISC_REQ:
./core/rtw_p2p.c:4202:				RTW_INFO("RTW_%s:P2P_DEVDISC_REQ, dialogToken=%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken);
./core/rtw_p2p.c:4204:			case P2P_DEVDISC_RESP:
./core/rtw_p2p.c:4205:				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
./core/rtw_p2p.c:4206:				RTW_INFO("RTW_%s:P2P_DEVDISC_RESP, dialogToken=%d, status:%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken, cont ? *cont : -1);
./core/rtw_p2p.c:4208:			case P2P_PROVISION_DISC_REQ: {
./core/rtw_p2p.c:4214:				RTW_INFO("RTW_%s:P2P_PROVISION_DISC_REQ, dialogToken=%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken);
./core/rtw_p2p.c:4223:						if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen)) {
./core/rtw_p2p.c:4236:			case P2P_PROVISION_DISC_RESP:
./core/rtw_p2p.c:4237:				RTW_INFO("RTW_%s:P2P_PROVISION_DISC_RESP, dialogToken=%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken);
./core/rtw_p2p.c:4246:	} else if (category == RTW_WLAN_CATEGORY_P2P) {
./core/rtw_p2p.c:4251:		RTW_INFO("ACTION_CATEGORY_P2P: OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
./core/rtw_p2p.c:4258:		case P2P_NOTICE_OF_ABSENCE:
./core/rtw_p2p.c:4259:			RTW_INFO("RTW_%s:P2P_NOTICE_OF_ABSENCE, dialogToken=%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken);
./core/rtw_p2p.c:4261:		case P2P_PRESENCE_REQUEST:
./core/rtw_p2p.c:4262:			RTW_INFO("RTW_%s:P2P_PRESENCE_REQUEST, dialogToken=%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken);
./core/rtw_p2p.c:4264:		case P2P_PRESENCE_RESPONSE:
./core/rtw_p2p.c:4265:			RTW_INFO("RTW_%s:P2P_PRESENCE_RESPONSE, dialogToken=%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken);
./core/rtw_p2p.c:4267:		case P2P_GO_DISC_REQUEST:
./core/rtw_p2p.c:4268:			RTW_INFO("RTW_%s:P2P_GO_DISC_REQUEST, dialogToken=%d\n", (tx == _TRUE) ? "Tx" : "Rx", dialogToken);
./core/rtw_p2p.c:4295:	case P2P_FIND_PHASE_WK:
./core/rtw_p2p.c:4299:	case P2P_RESTORE_STATE_WK:
./core/rtw_p2p.c:4303:	case P2P_PRE_TX_PROVDISC_PROCESS_WK:
./core/rtw_p2p.c:4314:	case P2P_PRE_TX_INVITEREQ_PROCESS_WK:
./core/rtw_p2p.c:4325:	case P2P_PRE_TX_NEGOREQ_PROCESS_WK:
./core/rtw_p2p.c:4337:	case P2P_AP_P2P_CH_SWITCH_PROCESS_WK:
./core/rtw_p2p.c:4343:	case P2P_RO_CH_WK:
./core/rtw_p2p.c:4346:	case P2P_CANCEL_RO_CH_WK:
./core/rtw_p2p.c:4366:	u8	p2p_attr[MAX_P2P_IE_LEN] = { 0x00 };/* NoA length should be n*(13) + 2 */
./core/rtw_p2p.c:4380:		/* Get P2P Manageability IE. */
./core/rtw_p2p.c:4381:		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_MANAGEABILITY, p2p_attr, &attr_contentlen)) {
./core/rtw_p2p.c:4386:		/* Get the next P2P IE */
./core/rtw_p2p.c:4393:#ifdef CONFIG_P2P_PS
./core/rtw_p2p.c:4408:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:4427:		noa_attr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_NOA, NULL, &attr_contentlen);
./core/rtw_p2p.c:4432:			if ((pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
./core/rtw_p2p.c:4442:					while (noa_offset < attr_contentlen && noa_num < P2P_MAX_NOA_NUM) {
./core/rtw_p2p.c:4462:					pwdinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
./core/rtw_p2p.c:4465:						p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
./core/rtw_p2p.c:4467:					pwdinfo->p2p_ps_mode = P2P_PS_NOA;
./core/rtw_p2p.c:4468:					p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
./core/rtw_p2p.c:4469:				} else if (pwdinfo->p2p_ps_mode > P2P_PS_NONE)
./core/rtw_p2p.c:4470:					p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
./core/rtw_p2p.c:4476:		/* Get the next P2P IE */
./core/rtw_p2p.c:4482:		if ((pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == _FALSE))
./core/rtw_p2p.c:4483:			p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
./core/rtw_p2p.c:4496:	case P2P_PS_DISABLE:
./core/rtw_p2p.c:4499:		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_P2P_PS_OFFLOAD, (u8 *)(&p2p_ps_state));
./core/rtw_p2p.c:4505:		pwdinfo->p2p_ps_mode = P2P_PS_NONE;
./core/rtw_p2p.c:4513:	case P2P_PS_ENABLE:
./core/rtw_p2p.c:4520:			pwdinfo->p2p_ps_mode = P2P_PS_NONE;
./core/rtw_p2p.c:4521:			RTW_DBG(FUNC_ADPT_FMT" Block P2P PS under site survey or LINKING\n", FUNC_ADPT_ARG(padapter));
./core/rtw_p2p.c:4524:		if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
./core/rtw_p2p.c:4528:					RTW_INFO("P2P PS enble under MCC\n");
./core/rtw_p2p.c:4543:			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_P2P_PS_OFFLOAD, (u8 *)(&p2p_ps_state));
./core/rtw_p2p.c:4546:	case P2P_PS_SCAN:
./core/rtw_p2p.c:4547:	case P2P_PS_SCAN_DONE:
./core/rtw_p2p.c:4548:	case P2P_PS_ALLSTASLEEP:
./core/rtw_p2p.c:4549:		if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
./core/rtw_p2p.c:4551:			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_P2P_PS_OFFLOAD, (u8 *)(&p2p_ps_state));
./core/rtw_p2p.c:4572:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
./core/rtw_p2p.c:4595:		pdrvextra_cmd_parm->ec_id = P2P_PS_WK_CID;
./core/rtw_p2p.c:4612:#endif /* CONFIG_P2P_PS */
./core/rtw_p2p.c:4619:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:4625:#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
./core/rtw_p2p.c:4629:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./core/rtw_p2p.c:4638:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:4644:#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
./core/rtw_p2p.c:4648:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./core/rtw_p2p.c:4657:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:4660:	p2p_protocol_wk_cmd(adapter, P2P_RESTORE_STATE_WK);
./core/rtw_p2p.c:4670:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:4676:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
./core/rtw_p2p.c:4678:			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK);
./core/rtw_p2p.c:4680:			/* _set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT ); */
./core/rtw_p2p.c:4682:	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING)) {
./core/rtw_p2p.c:4684:			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_NEGOREQ_PROCESS_WK);
./core/rtw_p2p.c:4685:	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ)) {
./core/rtw_p2p.c:4687:			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_INVITEREQ_PROCESS_WK);
./core/rtw_p2p.c:4699:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:4704:	p2p_protocol_wk_cmd(adapter, P2P_FIND_PHASE_WK);
./core/rtw_p2p.c:4716:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:4723:	p2p_protocol_wk_cmd(adapter, P2P_AP_P2P_CH_SWITCH_PROCESS_WK);
./core/rtw_p2p.c:4744:	/* Used in P2P and TDLS */
./core/rtw_p2p.c:4755:	pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
./core/rtw_p2p.c:4757:	/* Used in P2P */
./core/rtw_p2p.c:4965:#ifdef CONFIG_P2P
./core/rtw_p2p.c:4976:void init_wifidirect_info(_adapter *padapter, enum P2P_ROLE role)
./core/rtw_p2p.c:4992:	if (role != P2P_ROLE_DISABLE
./core/rtw_p2p.c:5015:	if (role == P2P_ROLE_DEVICE) {
./core/rtw_p2p.c:5016:		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./core/rtw_p2p.c:5019:			rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
./core/rtw_p2p.c:5022:			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
./core/rtw_p2p.c:5025:		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_LISTEN);
./core/rtw_p2p.c:5026:	} else if (role == P2P_ROLE_CLIENT) {
./core/rtw_p2p.c:5027:		rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./core/rtw_p2p.c:5028:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:5030:		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:5031:	} else if (role == P2P_ROLE_GO) {
./core/rtw_p2p.c:5032:		rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./core/rtw_p2p.c:5033:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:5035:		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
./core/rtw_p2p.c:5038:	/*	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 )	 */
./core/rtw_p2p.c:5054:	pwdinfo->invitereq_info.token = 3;	/*	Token used for P2P invitation request frame. */
./core/rtw_p2p.c:5060:	_rtw_memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
./core/rtw_p2p.c:5062:	rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
./core/rtw_p2p.c:5078:	pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
./core/rtw_p2p.c:5094:	pwdinfo->ext_listen_period = 3000; /* The time period to be available for P2P during nego */
./core/rtw_p2p.c:5117:#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
./core/rtw_p2p.c:5121:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./core/rtw_p2p.c:5125:#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
./core/rtw_p2p.c:5129:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./core/rtw_p2p.c:5133:void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
./core/rtw_p2p.c:5141:#ifdef CONFIG_DBG_P2P
./core/rtw_p2p.c:5145: * @role: P2P role
./core/rtw_p2p.c:5148:const char *rtw_p2p_role_txt(enum P2P_ROLE role)
./core/rtw_p2p.c:5151:	case P2P_ROLE_DISABLE:
./core/rtw_p2p.c:5152:		return "P2P_ROLE_DISABLE";
./core/rtw_p2p.c:5153:	case P2P_ROLE_DEVICE:
./core/rtw_p2p.c:5154:		return "P2P_ROLE_DEVICE";
./core/rtw_p2p.c:5155:	case P2P_ROLE_CLIENT:
./core/rtw_p2p.c:5156:		return "P2P_ROLE_CLIENT";
./core/rtw_p2p.c:5157:	case P2P_ROLE_GO:
./core/rtw_p2p.c:5158:		return "P2P_ROLE_GO";
./core/rtw_p2p.c:5166: * @state: P2P state
./core/rtw_p2p.c:5169:const char *rtw_p2p_state_txt(enum P2P_STATE state)
./core/rtw_p2p.c:5172:	case P2P_STATE_NONE:
./core/rtw_p2p.c:5173:		return "P2P_STATE_NONE";
./core/rtw_p2p.c:5174:	case P2P_STATE_IDLE:
./core/rtw_p2p.c:5175:		return "P2P_STATE_IDLE";
./core/rtw_p2p.c:5176:	case P2P_STATE_LISTEN:
./core/rtw_p2p.c:5177:		return "P2P_STATE_LISTEN";
./core/rtw_p2p.c:5178:	case P2P_STATE_SCAN:
./core/rtw_p2p.c:5179:		return "P2P_STATE_SCAN";
./core/rtw_p2p.c:5180:	case P2P_STATE_FIND_PHASE_LISTEN:
./core/rtw_p2p.c:5181:		return "P2P_STATE_FIND_PHASE_LISTEN";
./core/rtw_p2p.c:5182:	case P2P_STATE_FIND_PHASE_SEARCH:
./core/rtw_p2p.c:5183:		return "P2P_STATE_FIND_PHASE_SEARCH";
./core/rtw_p2p.c:5184:	case P2P_STATE_TX_PROVISION_DIS_REQ:
./core/rtw_p2p.c:5185:		return "P2P_STATE_TX_PROVISION_DIS_REQ";
./core/rtw_p2p.c:5186:	case P2P_STATE_RX_PROVISION_DIS_RSP:
./core/rtw_p2p.c:5187:		return "P2P_STATE_RX_PROVISION_DIS_RSP";
./core/rtw_p2p.c:5188:	case P2P_STATE_RX_PROVISION_DIS_REQ:
./core/rtw_p2p.c:5189:		return "P2P_STATE_RX_PROVISION_DIS_REQ";
./core/rtw_p2p.c:5190:	case P2P_STATE_GONEGO_ING:
./core/rtw_p2p.c:5191:		return "P2P_STATE_GONEGO_ING";
./core/rtw_p2p.c:5192:	case P2P_STATE_GONEGO_OK:
./core/rtw_p2p.c:5193:		return "P2P_STATE_GONEGO_OK";
./core/rtw_p2p.c:5194:	case P2P_STATE_GONEGO_FAIL:
./core/rtw_p2p.c:5195:		return "P2P_STATE_GONEGO_FAIL";
./core/rtw_p2p.c:5196:	case P2P_STATE_RECV_INVITE_REQ_MATCH:
./core/rtw_p2p.c:5197:		return "P2P_STATE_RECV_INVITE_REQ_MATCH";
./core/rtw_p2p.c:5198:	case P2P_STATE_PROVISIONING_ING:
./core/rtw_p2p.c:5199:		return "P2P_STATE_PROVISIONING_ING";
./core/rtw_p2p.c:5200:	case P2P_STATE_PROVISIONING_DONE:
./core/rtw_p2p.c:5201:		return "P2P_STATE_PROVISIONING_DONE";
./core/rtw_p2p.c:5202:	case P2P_STATE_TX_INVITE_REQ:
./core/rtw_p2p.c:5203:		return "P2P_STATE_TX_INVITE_REQ";
./core/rtw_p2p.c:5204:	case P2P_STATE_RX_INVITE_RESP_OK:
./core/rtw_p2p.c:5205:		return "P2P_STATE_RX_INVITE_RESP_OK";
./core/rtw_p2p.c:5206:	case P2P_STATE_RECV_INVITE_REQ_DISMATCH:
./core/rtw_p2p.c:5207:		return "P2P_STATE_RECV_INVITE_REQ_DISMATCH";
./core/rtw_p2p.c:5208:	case P2P_STATE_RECV_INVITE_REQ_GO:
./core/rtw_p2p.c:5209:		return "P2P_STATE_RECV_INVITE_REQ_GO";
./core/rtw_p2p.c:5210:	case P2P_STATE_RECV_INVITE_REQ_JOIN:
./core/rtw_p2p.c:5211:		return "P2P_STATE_RECV_INVITE_REQ_JOIN";
./core/rtw_p2p.c:5212:	case P2P_STATE_RX_INVITE_RESP_FAIL:
./core/rtw_p2p.c:5213:		return "P2P_STATE_RX_INVITE_RESP_FAIL";
./core/rtw_p2p.c:5214:	case P2P_STATE_RX_INFOR_NOREADY:
./core/rtw_p2p.c:5215:		return "P2P_STATE_RX_INFOR_NOREADY";
./core/rtw_p2p.c:5216:	case P2P_STATE_TX_INFOR_NOREADY:
./core/rtw_p2p.c:5217:		return "P2P_STATE_TX_INFOR_NOREADY";
./core/rtw_p2p.c:5223:void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line)
./core/rtw_p2p.c:5226:		enum P2P_STATE old_state = _rtw_p2p_state(wdinfo);
./core/rtw_p2p.c:5228:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d set_state from %s to %s\n", caller, line
./core/rtw_p2p.c:5232:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d set_state to same state %s\n", caller, line
./core/rtw_p2p.c:5237:void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line)
./core/rtw_p2p.c:5240:		enum P2P_STATE old_state = _rtw_p2p_pre_state(wdinfo);
./core/rtw_p2p.c:5242:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d set_pre_state from %s to %s\n", caller, line
./core/rtw_p2p.c:5246:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d set_pre_state to same state %s\n", caller, line
./core/rtw_p2p.c:5255:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d restore from %s to %s\n", caller, line
./core/rtw_p2p.c:5260:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d restore no pre state, cur state %s\n", caller, line
./core/rtw_p2p.c:5266:void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line)
./core/rtw_p2p.c:5269:		enum P2P_ROLE old_role = wdinfo->role;
./core/rtw_p2p.c:5271:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d set_role from %s to %s\n", caller, line
./core/rtw_p2p.c:5275:		RTW_INFO("[CONFIG_DBG_P2P]%s:%d set_role to same role %s\n", caller, line
./core/rtw_p2p.c:5280:#endif /* CONFIG_DBG_P2P */
./core/rtw_p2p.c:5283:int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
./core/rtw_p2p.c:5288:	if (role == P2P_ROLE_DEVICE || role == P2P_ROLE_CLIENT || role == P2P_ROLE_GO) {
./core/rtw_p2p.c:5289:#if defined(CONFIG_CONCURRENT_MODE) && (!defined(RTW_P2P_GROUP_INTERFACE) || !RTW_P2P_GROUP_INTERFACE)
./core/rtw_p2p.c:5291:		/*	The driver just supports 1 P2P group operation. */
./core/rtw_p2p.c:5292:		/*	So, this function will do nothing if the buddy adapter had enabled the P2P function. */
./core/rtw_p2p.c:5293:		/*if(!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
./core/rtw_p2p.c:5295:		/*The buddy adapter had enabled the P2P function.*/
./core/rtw_p2p.c:5307:		/*	In the P2P mode, the driver should not support the b mode. */
./core/rtw_p2p.c:5314:		/* Enable P2P function */
./core/rtw_p2p.c:5322:		rtw_hal_set_odm_var(padapter, HAL_ODM_P2P_STATE, NULL, _TRUE);
./core/rtw_p2p.c:5328:	} else if (role == P2P_ROLE_DISABLE) {
./core/rtw_p2p.c:5337:		/* Disable P2P function */
./core/rtw_p2p.c:5338:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./core/rtw_p2p.c:5349:			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
./core/rtw_p2p.c:5350:			rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_NONE);
./core/rtw_p2p.c:5351:			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DISABLE);
./core/rtw_p2p.c:5355:			_rtw_memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
./core/rtw_p2p.c:5359:		rtw_hal_set_odm_var(padapter, HAL_ODM_P2P_STATE, NULL, _FALSE);
./core/rtw_p2p.c:5386:#endif /* CONFIG_P2P */
./core/rtw_pwrctrl.c:204:#ifdef CONFIG_P2P
./core/rtw_pwrctrl.c:224:#ifdef CONFIG_P2P
./core/rtw_pwrctrl.c:232:				#if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
./core/rtw_pwrctrl.c:236:				#elif defined(CONFIG_P2P)
./core/rtw_pwrctrl.c:237:				|| rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)
./core/rtw_pwrctrl.c:238:				|| rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN)
./core/rtw_pwrctrl.c:652:		#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_P2P_WOWLAN)
./core/rtw_pwrctrl.c:671:		#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_P2P_WOWLAN)
./core/rtw_pwrctrl.c:676:		#endif /*#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_P2P_WOWLAN)*/
./core/rtw_pwrctrl.c:712:		#if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
./core/rtw_pwrctrl.c:859:#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_P2P_WOWLAN)
./core/rtw_pwrctrl.c:866:#ifdef CONFIG_P2P
./core/rtw_pwrctrl.c:868:#endif /* CONFIG_P2P */
./core/rtw_pwrctrl.c:926:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:928:#endif /* CONFIG_P2P_PS */
./core/rtw_pwrctrl.c:934:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:936:#endif /* CONFIG_P2P_PS */
./core/rtw_pwrctrl.c:964:#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_P2P_WOWLAN)
./core/rtw_pwrctrl.c:1028:#ifdef CONFIG_P2P_WOWLAN
./core/rtw_pwrctrl.c:1030:#endif /* CONFIG_P2P_WOWLAN */
./core/rtw_pwrctrl.c:1091:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:1094:				p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 0);
./core/rtw_pwrctrl.c:1095:#endif /* CONFIG_P2P_PS */
./core/rtw_pwrctrl.c:1177:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:1178:	if (padapter->wdinfo.p2p_ps_mode == P2P_PS_NOA) {
./core/rtw_pwrctrl.c:1179:		return;/* supporting p2p client ps NOA via H2C_8723B_P2P_PS_OFFLOAD */
./core/rtw_pwrctrl.c:1181:#endif /* CONFIG_P2P_PS */
./core/rtw_pwrctrl.c:1326:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:1327:		p2p_ps_wk_cmd(pri_padapter, P2P_PS_DISABLE, 0);
./core/rtw_pwrctrl.c:1328:#endif /* CONFIG_P2P_PS */
./core/rtw_pwrctrl.c:1388:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:1393:			if (pwdinfo->p2p_ps_mode > P2P_PS_NONE)
./core/rtw_pwrctrl.c:1394:				p2p_ps_wk_cmd(iface, P2P_PS_DISABLE, enqueue);
./core/rtw_pwrctrl.c:1396:#endif /* CONFIG_P2P_PS */
./core/rtw_pwrctrl.c:1975:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:1979:			if (iface->wdinfo.p2p_ps_mode > P2P_PS_NONE) {
./core/rtw_pwrctrl.c:2033:#ifdef CONFIG_P2P_PS
./core/rtw_pwrctrl.c:2037:			if (iface->wdinfo.p2p_ps_mode > P2P_PS_NONE) {
./core/rtw_recv.c:4246:	    ((*pcategory == RTW_WLAN_CATEGORY_TDLS) || (*pcategory == RTW_WLAN_CATEGORY_P2P))) {
./core/rtw_tdls.c:3235:	u8 category = RTW_WLAN_CATEGORY_P2P;
./core/rtw_tdls.c:3249:			if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./core/rtw_tdls.c:3265:	u8 category = RTW_WLAN_CATEGORY_P2P;
./core/rtw_tdls.c:3279:			if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./core/rtw_wlan_util.c:456:			if (iface->wdinfo.listen_channel == ch && !rtw_p2p_chk_state(&iface->wdinfo, P2P_STATE_NONE))
./core/rtw_wlan_util.c:734:int is_IBSS_empty(_adapter *padapter)
./core/rtw_wlan_util.c:1474:#if defined(CONFIG_P2P) && defined(CONFIG_WFD)
./core/rtw_wlan_util.c:1507:#endif /* defined(CONFIG_P2P) && defined(CONFIG_WFD) */
./core/rtw_wlan_util.c:3122:#ifdef CONFIG_P2P
./core/rtw_wlan_util.c:3126:	/*	In the P2P mode, the driver should not support the b mode. */
./core/rtw_wlan_util.c:3128:	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./core/rtw_wlan_util.c:3130:#endif /* CONFIG_P2P */
./core/rtw_wlan_util.c:3354:	if (updateCap & cIBSS) {
./core/rtw_wlan_util.c:3393:#ifdef CONFIG_P2P
./core/rtw_wlan_util.c:3395:#endif /* CONFIG_P2P */
./core/rtw_wlan_util.c:3445:		#ifdef CONFIG_P2P
./core/rtw_wlan_util.c:3446:		&& (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
./core/rtw_wlan_util.c:4310:	/* IBSS Parameter Set... */
./core/rtw_wlan_util.c:4313:	pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &len);
./hal/hal_btcoex.c:553:#ifdef CONFIG_P2P
./hal/hal_btcoex.c:554:	if (!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE))
./hal/hal_btcoex.c:556:#endif /* CONFIG_P2P */
./hal/hal_btcoex.c:561:				portConnectedStatus |= WIFI_P2P_GO_CONNECTED;
./hal/hal_btcoex.c:566:				portConnectedStatus |= WIFI_P2P_GC_CONNECTED;
./hal/hal_btcoex.c:1232:	case BTC_GET_U1_WIFI_P2P_CHNL:
./hal/hal_btcoex.c:1233:#ifdef CONFIG_P2P
./hal/hal_btcoex.c:1775:	u8			wifiChnl = 0, wifiP2PChnl = 0, nScanAPNum = 0, FwPSState;
./hal/hal_btcoex.c:1871:		((wifiLinkStatus & WIFI_HS_CONNECTED) ? 1 : 0), ((wifiLinkStatus & WIFI_P2P_GO_CONNECTED) ? 1 : 0),
./hal/hal_btcoex.c:1872:		((wifiLinkStatus & WIFI_P2P_GC_CONNECTED) ? 1 : 0));
./hal/hal_btcoex.c:1898:	wifiP2PChnl = wifi_link_info.p2p_center_channel;
./hal/hal_btcoex.c:1900:	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dBm/ %d/ %d/ %d", "RSSI/ STA_Chnl/ P2P_Chnl/ BI",
./hal/hal_btcoex.c:1901:		wifiRssi-100, wifiChnl, wifiP2PChnl, wifiBcnInterval);
./hal/hal_com.c:4447:				#ifdef CONFIG_P2P
./hal/hal_com.c:4456:				#ifdef CONFIG_P2P
./hal/hal_com.c:4495:	RTW_INFO("[IFS_ASSOC_STATUS] - P2P-GC :%d", p2p_gc_num);
./hal/hal_com.c:4496:	RTW_INFO("[IFS_ASSOC_STATUS] - P2P-GO :%d", p2p_go_num);
./hal/hal_com.c:4539:#ifdef CONFIG_P2P_PS
./hal/hal_com.c:4550:	HAL_P2P_PS_PARA p2p_ps_para;
./hal/hal_com.c:4555:	_rtw_memset(&p2p_ps_para, 0, sizeof(HAL_P2P_PS_PARA));
./hal/hal_com.c:4564:		if (p2p_ps_state != P2P_PS_DISABLE) {
./hal/hal_com.c:4572:	case P2P_PS_DISABLE:
./hal/hal_com.c:4573:		RTW_INFO("P2P_PS_DISABLE\n");
./hal/hal_com.c:4574:		_rtw_memset(&p2p_ps_para , 0, sizeof(HAL_P2P_PS_PARA));
./hal/hal_com.c:4577:	case P2P_PS_ENABLE:
./hal/hal_com.c:4578:		RTW_INFO("P2P_PS_ENABLE\n");
./hal/hal_com.c:4589:			if (pwdinfo->role == P2P_ROLE_GO) {
./hal/hal_com.c:4603:#ifdef CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./hal/hal_com.c:4608:#endif /* CONFIG_P2P_PS_NOA_USE_MACID_SLEEP */
./hal/hal_com.c:4609:			/* config P2P NoA Descriptor Register */
./hal/hal_com.c:4628:	case P2P_PS_SCAN:
./hal/hal_com.c:4631:		RTW_INFO("P2P_PS_SCAN\n");
./hal/hal_com.c:4642:	case P2P_PS_SCAN_DONE:
./hal/hal_com.c:4645:		RTW_INFO("P2P_PS_SCAN_DONE\n");
./hal/hal_com.c:4648:		pwdinfo->p2p_ps_state = P2P_PS_ENABLE;
./hal/hal_com.c:4661:	if (p2p_ps_state != P2P_PS_ENABLE || (&p2p_ps_para)->noa_en == 0) {
./hal/hal_com.c:4670:#endif /* CONFIG_P2P */
./hal/hal_com.c:5948:	#ifdef CONFIG_P2P_WOWLAN
./hal/hal_com.c:5950:			RTW_INFO("P2P OFFLOAD ENABLE\n");
./hal/hal_com.c:5951:			SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(u1H2CRemoteWakeCtrlParm, 1);
./hal/hal_com.c:5953:			RTW_INFO("P2P OFFLOAD DISABLE\n");
./hal/hal_com.c:5954:			SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(u1H2CRemoteWakeCtrlParm, 0);
./hal/hal_com.c:5956:	#endif /* CONFIG_P2P_WOWLAN */
./hal/hal_com.c:6348:#ifdef CONFIG_P2P_WOWLAN
./hal/hal_com.c:6384:static void rtw_hal_construct_P2PBeacon(_adapter *padapter, u8 *pframe, u32 *pLength)
./hal/hal_com.c:6403:#ifdef CONFIG_P2P
./hal/hal_com.c:6405:#endif /* CONFIG_P2P */
./hal/hal_com.c:6435:#ifdef CONFIG_P2P
./hal/hal_com.c:6436:		/* for P2P : Primary Device Type & Device Name */
./hal/hal_com.c:6441:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && wpsie && wpsielen > 0) {
./hal/hal_com.c:6530:#endif /* CONFIG_P2P */
./hal/hal_com.c:6557:#ifdef CONFIG_P2P
./hal/hal_com.c:6558:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./hal/hal_com.c:6581:#endif /* CONFIG_P2P */
./hal/hal_com.c:6621:		/* IBSS Parameter Set... */
./hal/hal_com.c:6624:		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
./hal/hal_com.c:6650:	RTW_INFO("======> DBG MSG FOR CONSTRAUCT P2P BEACON\n");
./hal/hal_com.c:6656:	RTW_INFO("<====== DBG MSG FOR CONSTRAUCT P2P BEACON\n");
./hal/hal_com.c:6661:static void rtw_hal_construct_P2PProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength)
./hal/hal_com.c:6720:	/*	ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec) */
./hal/hal_com.c:6733:	/*	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 ) */
./hal/hal_com.c:6747:			/* P2P IE */
./hal/hal_com.c:6937:	RTW_INFO("======> DBG MSG FOR CONSTRAUCT P2P Probe Rsp\n");
./hal/hal_com.c:6943:	RTW_INFO("<====== DBG MSG FOR CONSTRAUCT P2P Probe Rsp\n");
./hal/hal_com.c:6946:static void rtw_hal_construct_P2PNegoRsp(_adapter *padapter, u8 *pframe, u32 *pLength)
./hal/hal_com.c:6950:	u8			action = P2P_PUB_ACTION_ACTION;
./hal/hal_com.c:6951:	u32			p2poui = cpu_to_be32(P2POUI);
./hal/hal_com.c:6952:	u8			oui_subtype = P2P_GO_NEGO_RESP;
./hal/hal_com.c:7049:	/*	P2P IE Section. */
./hal/hal_com.c:7051:	/*	P2P OUI */
./hal/hal_com.c:7056:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./hal/hal_com.c:7059:	/*	According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes */
./hal/hal_com.c:7061:	/*	2. P2P Capability */
./hal/hal_com.c:7065:	/*	6. Intended P2P Interface Address */
./hal/hal_com.c:7073:	/*	P2P Status */
./hal/hal_com.c:7075:	p2pie[p2pielen++] = P2P_ATTR_STATUS;
./hal/hal_com.c:7084:	/*	P2P Capability */
./hal/hal_com.c:7086:	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
./hal/hal_com.c:7095:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
./hal/hal_com.c:7097:		/*	According to the P2P specification */
./hal/hal_com.c:7098:		/*	if the sending device will be client, the P2P Capability should be reserved of group negotation response frame */
./hal/hal_com.c:7102:		p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
./hal/hal_com.c:7107:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
./hal/hal_com.c:7109:		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
./hal/hal_com.c:7113:	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
./hal/hal_com.c:7131:	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
./hal/hal_com.c:7138:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P GO */
./hal/hal_com.c:7139:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P Client */
./hal/hal_com.c:7143:	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./hal/hal_com.c:7173:	/*	Intended P2P Interface Address	 */
./hal/hal_com.c:7175:	p2pie[p2pielen++] = P2P_ATTR_INTENDED_IF_ADDR;
./hal/hal_com.c:7187:	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
./hal/hal_com.c:7259:	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./hal/hal_com.c:7262:	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./hal/hal_com.c:7268:	/*	P2P Device Address */
./hal/hal_com.c:7273:	/*	This field should be big endian. Noted by P2P specification. */
./hal/hal_com.c:7308:	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./hal/hal_com.c:7311:		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
./hal/hal_com.c:7350:static void rtw_hal_construct_P2PInviteRsp(_adapter *padapter, u8 *pframe, u32 *pLength)
./hal/hal_com.c:7353:	u8			action = P2P_PUB_ACTION_ACTION;
./hal/hal_com.c:7354:	u32			p2poui = cpu_to_be32(P2POUI);
./hal/hal_com.c:7355:	u8			oui_subtype = P2P_INVIT_RESP;
./hal/hal_com.c:7408:	/*	P2P IE Section. */
./hal/hal_com.c:7410:	/*	P2P OUI */
./hal/hal_com.c:7415:	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./hal/hal_com.c:7418:	/*	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes */
./hal/hal_com.c:7422:	/*	4. P2P Group BSSID	( Only GO ) */
./hal/hal_com.c:7425:	/*	P2P Status */
./hal/hal_com.c:7427:	p2pie[p2pielen++] = P2P_ATTR_STATUS;
./hal/hal_com.c:7434:	p2pie[p2pielen++] = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
./hal/hal_com.c:7438:	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
./hal/hal_com.c:7445:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P GO */
./hal/hal_com.c:7446:	p2pie[p2pielen++] = 200;	/*	2 seconds needed to be the P2P Client */
./hal/hal_com.c:7450:	if (status_code == P2P_STATUS_SUCCESS) {
./hal/hal_com.c:7453:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./hal/hal_com.c:7454:			/*	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO */
./hal/hal_com.c:7455:			/*	In this case, the P2P Invitation response frame should carry the two more P2P attributes. */
./hal/hal_com.c:7457:			/*	Second one is P2P Group BSSID attribute. */
./hal/hal_com.c:7461:			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
./hal/hal_com.c:7483:			/*	P2P Group BSSID */
./hal/hal_com.c:7485:			p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
./hal/hal_com.c:7492:			/*	P2P Device Address for GO */
./hal/hal_com.c:7500:		p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
./hal/hal_com.c:7597:static void rtw_hal_construct_P2PProvisionDisRsp(_adapter *padapter, u8 *pframe, u32 *pLength)
./hal/hal_com.c:7600:	u8			action = P2P_PUB_ACTION_ACTION;
./hal/hal_com.c:7602:	u32			p2poui = cpu_to_be32(P2POUI);
./hal/hal_com.c:7603:	u8			oui_subtype = P2P_PROVISION_DISC_RESP;
./hal/hal_com.c:7709:u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter *adapter, PRSVDPAGE_LOC rsvdpageloc)
./hal/hal_com.c:7711:	u8 u1H2CP2PRsvdPageParm[H2C_P2PRSVDPAGE_LOC_LEN] = {0};
./hal/hal_com.c:7715:	RTW_INFO("P2PRsvdPageLoc: P2PBeacon=%d P2PProbeRsp=%d NegoRsp=%d InviteRsp=%d PDRsp=%d\n",
./hal/hal_com.c:7716:		 rsvdpageloc->LocP2PBeacon, rsvdpageloc->LocP2PProbeRsp,
./hal/hal_com.c:7720:	SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(u1H2CP2PRsvdPageParm, rsvdpageloc->LocProbeRsp);
./hal/hal_com.c:7721:	SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocPsPoll);
./hal/hal_com.c:7722:	SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocNullData);
./hal/hal_com.c:7723:	SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocQosNull);
./hal/hal_com.c:7724:	SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocBTQosNull);
./hal/hal_com.c:7726:	/* FillH2CCmd8723B(padapter, H2C_8723B_P2P_OFFLOAD_RSVD_PAGE, H2C_P2PRSVDPAGE_LOC_LEN, u1H2CP2PRsvdPageParm); */
./hal/hal_com.c:7728:				   H2C_P2P_OFFLOAD_RSVD_PAGE,
./hal/hal_com.c:7729:				   H2C_P2PRSVDPAGE_LOC_LEN,
./hal/hal_com.c:7730:				   u1H2CP2PRsvdPageParm);
./hal/hal_com.c:7738:	u8 offload_cmd[H2C_P2P_OFFLOAD_LEN] = {0};
./hal/hal_com.c:7740:	struct P2P_WoWlan_Offload_t *p2p_wowlan_offload = (struct P2P_WoWlan_Offload_t *)offload_cmd;
./hal/hal_com.c:7744:	_rtw_memset(p2p_wowlan_offload, 0 , sizeof(struct P2P_WoWlan_Offload_t));
./hal/hal_com.c:7747:	case P2P_ROLE_DEVICE:
./hal/hal_com.c:7748:		RTW_INFO("P2P_ROLE_DEVICE\n");
./hal/hal_com.c:7751:	case P2P_ROLE_CLIENT:
./hal/hal_com.c:7752:		RTW_INFO("P2P_ROLE_CLIENT\n");
./hal/hal_com.c:7755:	case P2P_ROLE_GO:
./hal/hal_com.c:7756:		RTW_INFO("P2P_ROLE_GO\n");
./hal/hal_com.c:7760:		RTW_INFO("P2P_ROLE_DISABLE\n");
./hal/hal_com.c:7769:				   H2C_P2P_OFFLOAD,
./hal/hal_com.c:7770:				   H2C_P2P_OFFLOAD_LEN,
./hal/hal_com.c:7774:	/* FillH2CCmd8723B(adapter, H2C_8723B_P2P_OFFLOAD, sizeof(struct P2P_WoWlan_Offload_t), (u8 *)p2p_wowlan_offload); */
./hal/hal_com.c:7776:#endif /* CONFIG_P2P_WOWLAN */
./hal/hal_com.c:7847:		/* IBSS Parameter Set... */
./hal/hal_com.c:7850:		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
./hal/hal_com.c:7995:	case Ndis802_11IBSS:
./hal/hal_com.c:10192:#ifdef CONFIG_P2P_WOWLAN
./hal/hal_com.c:10197:	u32 P2PNegoRspLength = 0, P2PInviteRspLength = 0;
./hal/hal_com.c:10198:	u32 P2PPDRspLength = 0, P2PProbeRspLength = 0, P2PBCNLength = 0;
./hal/hal_com.c:10201:	/* P2P Beacon */
./hal/hal_com.c:10202:	rsvd_page_loc->LocP2PBeacon = *page_num;
./hal/hal_com.c:10203:	rtw_hal_construct_P2PBeacon(adapter, &pframe[index], &P2PBCNLength);
./hal/hal_com.c:10205:				 P2PBCNLength, _FALSE, _FALSE, _FALSE);
./hal/hal_com.c:10209:		__FUNCTION__, &pframe[index - tx_desc], (P2PBCNLength + tx_desc));
./hal/hal_com.c:10212:	CurtPktPageNum = (u8)PageNum(tx_desc + P2PBCNLength, page_size);
./hal/hal_com.c:10217:	RSVD_PAGE_CFG("WOW-P2P-Beacon", CurtPktPageNum, *page_num, 0);
./hal/hal_com.c:10219:	/* P2P Probe rsp */
./hal/hal_com.c:10220:	rsvd_page_loc->LocP2PProbeRsp = *page_num;
./hal/hal_com.c:10221:	rtw_hal_construct_P2PProbeRsp(adapter, &pframe[index],
./hal/hal_com.c:10222:				      &P2PProbeRspLength);
./hal/hal_com.c:10224:				 P2PProbeRspLength, _FALSE, _FALSE, _FALSE);
./hal/hal_com.c:10227:	/*	__FUNCTION__, &pframe[index-tx_desc], (P2PProbeRspLength+tx_desc)); */
./hal/hal_com.c:10229:	CurtPktPageNum = (u8)PageNum(tx_desc + P2PProbeRspLength, page_size);
./hal/hal_com.c:10234:	RSVD_PAGE_CFG("WOW-P2P-ProbeRsp", CurtPktPageNum, *page_num, 0);
./hal/hal_com.c:10236:	/* P2P nego rsp */
./hal/hal_com.c:10238:	rtw_hal_construct_P2PNegoRsp(adapter, &pframe[index],
./hal/hal_com.c:10239:				     &P2PNegoRspLength);
./hal/hal_com.c:10241:				 P2PNegoRspLength, _FALSE, _FALSE, _FALSE);
./hal/hal_com.c:10246:	CurtPktPageNum = (u8)PageNum(tx_desc + P2PNegoRspLength, page_size);
./hal/hal_com.c:10251:	RSVD_PAGE_CFG("WOW-P2P-NegoRsp", CurtPktPageNum, *page_num, 0);
./hal/hal_com.c:10253:	/* P2P invite rsp */
./hal/hal_com.c:10255:	rtw_hal_construct_P2PInviteRsp(adapter, &pframe[index],
./hal/hal_com.c:10256:				       &P2PInviteRspLength);
./hal/hal_com.c:10258:				 P2PInviteRspLength, _FALSE, _FALSE, _FALSE);
./hal/hal_com.c:10263:	CurtPktPageNum = (u8)PageNum(tx_desc + P2PInviteRspLength, page_size);
./hal/hal_com.c:10268:	RSVD_PAGE_CFG("WOW-P2P-InviteRsp", CurtPktPageNum, *page_num, 0);
./hal/hal_com.c:10270:	/* P2P provision discovery rsp */
./hal/hal_com.c:10272:	rtw_hal_construct_P2PProvisionDisRsp(adapter,
./hal/hal_com.c:10273:					     &pframe[index], &P2PPDRspLength);
./hal/hal_com.c:10276:				 P2PPDRspLength, _FALSE, _FALSE, _FALSE);
./hal/hal_com.c:10281:	CurtPktPageNum = (u8)PageNum(tx_desc + P2PPDRspLength, page_size);
./hal/hal_com.c:10285:	*total_pkt_len = index + P2PPDRspLength;
./hal/hal_com.c:10286:	RSVD_PAGE_CFG("WOW-P2P-PDR", CurtPktPageNum, *page_num, *total_pkt_len);
./hal/hal_com.c:10292:#endif /* CONFIG_P2P_WOWLAN */
./hal/hal_com.c:10772:		/*RTW_INFO("[IFS_ASSOC_STATUS] - P2P-GC :%d", DEV_P2P_GC_NUM(adapter_to_dvobj(adapter)));*/
./hal/hal_com.c:10773:		/*RTW_INFO("[IFS_ASSOC_STATUS] - P2P-GO :%d", DEV_P2P_GO_NUM(adapter_to_dvobj(adapter)));*/
./hal/hal_com.c:11160:#ifdef CONFIG_P2P_WOWLAN
./hal/hal_com.c:11161:	/*======== P2P WOW * n page ======== */
./hal/hal_com.c:11167:#endif /* CONFIG_P2P_WOWLAN */
./hal/hal_com.c:11244:#ifdef CONFIG_P2P_WOWLAN
./hal/hal_com.c:11246:		rtw_hal_set_FwP2PRsvdPage_cmd(adapter, &RsvdPageLoc);
./hal/hal_com.c:11247:#endif /* CONFIG_P2P_WOWLAN */
./hal/hal_com.c:14623:	/* BIT0 */"P2P",
./hal/hal_com_c2h.h:65:	C2H_P2P_RPORT = 0x16,
./hal/hal_dm.c:922:	case HAL_ODM_P2P_STATE:
./hal/hal_dm.c:923:		odm_cmn_info_update(podmpriv, ODM_CMNINFO_WIFI_DIRECT, bSet);
./hal/hal_dm.c:1497:#ifdef CONFIG_P2P
./hal/hal_dm.c:1498:			if (!rtw_p2p_chk_role(&(iface)->wdinfo, P2P_ROLE_DISABLE))
./hal/hal_halmac.h:96:	u8 p2p_ctwin:1;		/* Enable P2P CTN WINDOWS function */
./hal/hal_halmac.h:97:	u8 p2p_bcn_area:1;	/* Enable P2P BCN area on function */
./hal/hal_halmac.h:195:int rtw_halmac_p2pps(struct dvobj_priv *dvobj, PHAL_P2P_PS_PARA pp2p_ps_para);
./hal/hal_intf.c:268:		networkType = Ndis802_11IBSS;
./hal/hal_mcc.c:78:	u8 p2p_noa_attr_ie[MAX_P2P_IE_LEN] = {0x00};
./hal/hal_mcc.c:92:	/* P2P OUI(4 bytes) */
./hal/hal_mcc.c:93:	_rtw_memcpy(p2p_noa_attr_ie, P2P_OUI, 4);
./hal/hal_mcc.c:97:	p2p_noa_attr_ie[p2p_noa_attr_len] = P2P_ATTR_NOA;
./hal/hal_mcc.c:186:	update_beacon(padapter, _VENDOR_SPECIFIC_IE_, P2P_OUI, _TRUE);
./hal/hal_mcc.c:203:	update_beacon(padapter, _VENDOR_SPECIFIC_IE_, P2P_OUI, _TRUE);
./hal/hal_mcc.c:1168:			RTW_INFO(FUNC_ADPT_FMT" P2P Role:%d, mlme state:0x%2x\n",
./hal/hal_mcc.c:2991:			if (iface->wdinfo.p2p_ps_mode == P2P_PS_NOA) {
./hal/hal_mcc.c:3487:				RTW_PRINT_SEL(sel, "P2P NoA:%s\n\n", p2p_ps_mode == P2P_PS_NOA ? "enable":"disable");
./hal/hal_mcc.c:3696:	case P2P_PS_NONE:
./hal/hal_mcc.c:3700:	case P2P_PS_NOA:
./hal/hal_mcc.c:3735:#ifdef CONFIG_P2P_PS
./hal/hal_mcc.c:3739:		if (iface->wdinfo.p2p_ps_mode == P2P_PS_NOA) {
./hal/hal_mcc.c:3744:#endif /* CONFIG_P2P_PS */
./hal/hal_mcc.c:3763:			/* 2 = favor P2P*/
./hal/hal_mcc.c:3768:				mccobjpriv->mchan_sched_mode = MCC_FAVOR_P2P;
./hal/phydm/phydm.c:2374:	case ODM_CMNINFO_P2P_LINK:
./hal/phydm/phydm.c:2463:	case ODM_CMNINFO_WIFI_DIRECT:
./hal/phydm/phydm.h:436:	ODM_CMNINFO_P2P_LINK,
./hal/phydm/phydm.h:452:	ODM_CMNINFO_WIFI_DIRECT,
./hal/phydm/phydm_beamforming.c:359:			PHYDM_DBG(dm, DBG_TXBF, "%s: BFee P_AID as IBSS=%d\n",
./hal/phydm/phydm_beamforming.c:1772:		ret = ACTING_AS_IBSS(((PADAPTER)(adapter)));
./hal/phydm/phydm_beamforming.h:130:	u16 mac_id; /*Used to Set Reg42C in IBSS mode. */
./hal/phydm/phydm_ccx.h:36:#define	ENV_MNTR_DBG_1	0	/*@debug 8812A & 8821A P2P Fail to get result*/
./hal/phydm/phydm_pre_define.h:716:	ODM_WIFI_DIRECT		= BIT(7),
./hal/phydm/phydm_types.h:126:	RT_P2P_SPIN_LOCK = 36,	/* Protect P2P context */
./hal/phydm/txbf/haltxbfinterface.c:74:		} else if (ACTING_AS_IBSS(((PADAPTER)adapter))) {
./hal/phydm/txbf/haltxbfinterface.c:238:		if (ACTING_AS_IBSS(((PADAPTER)adapter)) || ACTING_AS_AP(((PADAPTER)adapter)))
./hal/rtl8188f/rtl8188f_cmd.c:162:#ifdef CONFIG_P2P
./hal/rtl8188f/rtl8188f_cmd.c:164:#endif /* CONFIG_P2P */
./hal/rtl8188f/rtl8188f_cmd.c:202:#ifdef CONFIG_P2P
./hal/rtl8188f/rtl8188f_cmd.c:203:	if (!rtw_p2p_chk_state(wdinfo, P2P_STATE_NONE)) {
./hal/rtl8188f/rtl8188f_cmd.c:207:#endif /* CONFIG_P2P */
./hal/rtl8188f/rtl8188f_cmd.c:443:#ifdef CONFIG_P2P
./hal/rtl8188f/rtl8188f_cmd.c:449:	struct P2P_PS_Offload_t	*p2p_ps_offload = (struct P2P_PS_Offload_t *)(&pHalData->p2p_ps_offload);
./hal/rtl8188f/rtl8188f_cmd.c:455:	case P2P_PS_DISABLE:
./hal/rtl8188f/rtl8188f_cmd.c:456:		RTW_INFO("P2P_PS_DISABLE\n");
./hal/rtl8188f/rtl8188f_cmd.c:459:	case P2P_PS_ENABLE:
./hal/rtl8188f/rtl8188f_cmd.c:460:		RTW_INFO("P2P_PS_ENABLE\n");
./hal/rtl8188f/rtl8188f_cmd.c:464:			rtw_write8(padapter, REG_P2P_CTWIN, pwdinfo->ctwindow);
./hal/rtl8188f/rtl8188f_cmd.c:476:			/* config P2P NoA Descriptor Register */
./hal/rtl8188f/rtl8188f_cmd.c:496:			if (pwdinfo->role == P2P_ROLE_GO) {
./hal/rtl8188f/rtl8188f_cmd.c:505:	case P2P_PS_SCAN:
./hal/rtl8188f/rtl8188f_cmd.c:506:		RTW_INFO("P2P_PS_SCAN\n");
./hal/rtl8188f/rtl8188f_cmd.c:509:	case P2P_PS_SCAN_DONE:
./hal/rtl8188f/rtl8188f_cmd.c:510:		RTW_INFO("P2P_PS_SCAN_DONE\n");
./hal/rtl8188f/rtl8188f_cmd.c:512:		pwdinfo->p2p_ps_state = P2P_PS_ENABLE;
./hal/rtl8188f/rtl8188f_cmd.c:518:	FillH2CCmd8188F(padapter, H2C_8188F_P2P_PS_OFFLOAD, 1, (u8 *)p2p_ps_offload);
./hal/rtl8188f/rtl8188f_cmd.c:523:#endif /*CONFIG_P2P */
./hal/rtl8188f/rtl8188f_dm.c:239:#ifdef CONFIG_P2P
./hal/rtl8188f/rtl8188f_dm.c:244:#endif /*CONFIG_P2P */
./hal/rtl8188f/rtl8188f_hal_init.c:3257:			    | WL_FUNC_P2P
./hal/rtl8188f/rtl8188f_hal_init.c:4231:#ifdef CONFIG_P2P
./hal/rtl8188f/rtl8188f_hal_init.c:4232:		if (!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE)) {
./hal/rtl8188f/rtl8188f_hal_init.c:4944:#ifdef CONFIG_P2P
./hal/rtl8188f/rtl8188f_hal_init.c:4945:	case HW_VAR_H2C_FW_P2P_PS_OFFLOAD:
./hal/rtl8188f/rtl8188f_hal_init.c:4948:#endif /*CONFIG_P2P */
./include/autoconf.h:62:#define CONFIG_P2P
./include/autoconf.h:63:#ifdef CONFIG_P2P
./include/autoconf.h:68:	#define CONFIG_P2P_REMOVE_GROUP_INFO
./include/autoconf.h:70:	/* #define CONFIG_DBG_P2P */
./include/autoconf.h:71:	#define CONFIG_P2P_PS
./include/autoconf.h:72:	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
./include/autoconf.h:73:	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  /* replace CONFIG_P2P_CHK_INVITE_CH_LIST flag */
./include/autoconf.h:74:	/*#define CONFIG_P2P_INVITE_IOT*/
./include/drv_types.h:1284:#define DEV_P2P_DV_NUM(_dvobj)		MSTATE_P2P_DV_NUM(&((_dvobj)->iface_state))
./include/drv_types.h:1285:#define DEV_P2P_GC_NUM(_dvobj)		MSTATE_P2P_GC_NUM(&((_dvobj)->iface_state))
./include/drv_types.h:1286:#define DEV_P2P_GO_NUM(_dvobj)		MSTATE_P2P_GO_NUM(&((_dvobj)->iface_state))
./include/drv_types.h:1453:#ifdef CONFIG_P2P
./include/drv_types.h:1455:#endif /* CONFIG_P2P */
./include/drv_types.h:1460:#ifdef CONFIG_P2P
./include/drv_types.h:1462:#endif /* CONFIG_P2P */
./include/drv_types.h:1571:#ifdef CONFIG_P2P
./include/drv_types.h:1573:	/*	The driver will show the current P2P status when the upper application reads it. */
./include/drv_types.h:1574:	u8 bShowGetP2PState;
./include/hal_com.h:333:#define WL_FUNC_P2P			BIT0
./include/hal_com.h:693:#ifdef CONFIG_P2P_PS
./include/hal_com_h2c.h:53:	H2C_P2P_LPS_PARAM = 0x23,
./include/hal_com_h2c.h:54:	H2C_P2P_PS_OFFLOAD = 0x24,
./include/hal_com_h2c.h:111:	H2C_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
./include/hal_com_h2c.h:112:	H2C_P2P_OFFLOAD = 0x8B,
./include/hal_com_h2c.h:157:#define H2C_P2PRSVDPAGE_LOC_LEN	5
./include/hal_com_h2c.h:158:#define H2C_P2P_OFFLOAD_LEN	3
./include/hal_com_h2c.h:506:#define SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 1, __Value)
./include/hal_com_h2c.h:548:#ifdef CONFIG_P2P_WOWLAN
./include/hal_com_h2c.h:549:/* P2P_RsvdPage_0x8a */
./include/hal_com_h2c.h:550:#define SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
./include/hal_com_h2c.h:551:#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
./include/hal_com_h2c.h:552:#define SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
./include/hal_com_h2c.h:553:#define SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
./include/hal_com_h2c.h:554:#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
./include/hal_com_h2c.h:555:#endif /* CONFIG_P2P_WOWLAN */
./include/hal_com_h2c.h:612:#ifdef CONFIG_P2P_WOWLAN
./include/hal_com_h2c.h:613:	u8 LocP2PBeacon;
./include/hal_com_h2c.h:614:	u8 LocP2PProbeRsp;
./include/hal_com_h2c.h:618:#endif /* CONFIG_P2P_WOWLAN */
./include/hal_com_h2c.h:645:	#ifdef CONFIG_P2P_WOWLAN
./include/hal_com_h2c.h:647:		u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter *adapter, PRSVDPAGE_LOC rsvdpageloc);
./include/hal_com_h2c.h:650:	#endif /* CONFIG_P2P_WOWLAN */
./include/hal_com_reg.h:386:#define REG_P2P_CTWIN					0x0572 /* 1 Byte long (in unit of TU) */
./include/hal_com_reg.h:884:#define IMR_ATIMEND				BIT(10)		/* For 92C, ATIM Window End Interrupt. For 8723 and later ICs, it also means P2P CTWin End interrupt. */
./include/hal_com_reg.h:1552:#define DUAL_TSF_RST_P2P		BIT(4)
./include/hal_data.h:309:} HAL_P2P_PS_PARA, *PHAL_P2P_PS_PARA;
./include/hal_data.h:572:#ifdef CONFIG_P2P
./include/hal_data.h:573:#ifdef CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./include/hal_ic_cfg.h:112:	#ifdef CONFIG_P2P_PS
./include/hal_ic_cfg.h:113:		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./include/hal_ic_cfg.h:272:	#ifdef CONFIG_P2P_PS
./include/hal_ic_cfg.h:273:		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./include/hal_ic_cfg.h:355:	#ifdef CONFIG_P2P_PS
./include/hal_ic_cfg.h:356:		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./include/hal_ic_cfg.h:401:	#ifdef CONFIG_P2P_PS
./include/hal_ic_cfg.h:402:		#define CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./include/hal_intf.h:115:	HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
./include/hal_intf.h:263:	HAL_ODM_P2P_STATE,
./include/ieee80211.h:375:#define IEEE_IBSS_MAC_HASH_SIZE 31
./include/ieee80211.h:598:#define WLAN_CAPABILITY_IBSS (1<<1)
./include/ieee80211.h:668:#define WLAN_EID_IBSS_PARAMS 6
./include/ieee80211.h:680:#define WLAN_EID_IBSS_DFS 41
./include/ieee80211.h:1185:#define MFIE_TYPE_IBSS_SET   6
./include/ieee80211.h:1295:#define MAX_P2P_IE_LEN (256)
./include/ieee80211.h:1475:	RTW_WLAN_CATEGORY_P2P = 0x7f,/* P2P action frames */
./include/ieee80211.h:1487:	|| cat == RTW_WLAN_CATEGORY_P2P)
./include/ieee80211.h:1537:	ACT_PUBLIC_VENDOR = 9, /* for WIFI_DIRECT */
./include/ieee80211.h:1711: * @RTW_IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.
./include/ieee80211.h:1721:	RTW_IEEE80211_CHAN_NO_IBSS          = 1 << 2,
./include/ieee80211_ext.h:225:			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
./include/ieee80211_ext.h:237:			 * FH Params, DS Params, CF Params, IBSS Params */
./include/rtl8188e_cmd.h:29:	P2P_PS_OFFLOAD_EID = 8,
./include/rtl8188e_cmd.h:31:	P2P_PS_CTW_CMD_EID = 32,
./include/rtl8188e_cmd.h:56:	H2C_PS_P2P_OFFLOAD			= 0x24,
./include/rtl8188e_cmd.h:143:#ifdef CONFIG_P2P
./include/rtl8188e_cmd.h:145:#endif /* CONFIG_P2P */
./include/rtl8188f_cmd.h:41:	H2C_8188F_P2P_LPS_PARAM = 0x23,
./include/rtl8188f_cmd.h:42:	H2C_8188F_P2P_PS_OFFLOAD = 0x24,
./include/rtl8188f_cmd.h:79:	H2C_8188F_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
./include/rtl8188f_cmd.h:80:	H2C_8188F_P2P_OFFLOAD = 0x8B,
./include/rtl8188f_cmd.h:188:#ifdef CONFIG_P2P
./include/rtl8188f_cmd.h:190:#endif /* CONFIG_P2P */
./include/rtl8188f_cmd.h:198:#ifdef CONFIG_P2P_WOWLAN
./include/rtl8192e_cmd.h:35:	H2C_8192E_P2P_PS_OFFLOAD = 0x24,
./include/rtl8192e_cmd.h:48:	H2C_8192E_P2P_PS_MODE,
./include/rtl8192e_cmd.h:106:/* _P2P_PS_OFFLOAD */
./include/rtl8192e_cmd.h:107:#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
./include/rtl8192e_cmd.h:108:#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
./include/rtl8192e_cmd.h:109:#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
./include/rtl8192e_cmd.h:110:#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
./include/rtl8192e_cmd.h:111:#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
./include/rtl8192e_cmd.h:112:#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
./include/rtl8192e_cmd.h:125:#ifdef CONFIG_P2P_PS
./include/rtl8192e_cmd.h:127:#endif /* CONFIG_P2P */
./include/rtl8192f_cmd.h:41:	H2C_8192F_P2P_LPS_PARAM = 0x23,	
./include/rtl8192f_cmd.h:42:	H2C_8192F_P2P_PS_OFFLOAD = 0x24,	
./include/rtl8192f_cmd.h:79:	H2C_8192F_P2P_OFFLOAD_RSVD_PAGE = 0x8A,	
./include/rtl8192f_cmd.h:80:	H2C_8192F_P2P_OFFLOAD = 0x8B,
./include/rtl8192f_cmd.h:178:#ifdef CONFIG_P2P
./include/rtl8192f_cmd.h:180:#endif /* CONFIG_P2P */
./include/rtl8192f_cmd.h:188:#ifdef CONFIG_P2P_WOWLAN
./include/rtl8703b_cmd.h:41:	H2C_8703B_P2P_LPS_PARAM = 0x23,
./include/rtl8703b_cmd.h:42:	H2C_8703B_P2P_PS_OFFLOAD = 0x24,
./include/rtl8703b_cmd.h:79:	H2C_8703B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
./include/rtl8703b_cmd.h:80:	H2C_8703B_P2P_OFFLOAD = 0x8B,
./include/rtl8703b_cmd.h:187:#ifdef CONFIG_P2P
./include/rtl8703b_cmd.h:189:#endif /* CONFIG_P2P */
./include/rtl8703b_cmd.h:197:#ifdef CONFIG_P2P_WOWLAN
./include/rtl8710b_cmd.h:41:	H2C_8710B_P2P_LPS_PARAM = 0x23,
./include/rtl8710b_cmd.h:42:	H2C_8710B_P2P_PS_OFFLOAD = 0x24,
./include/rtl8710b_cmd.h:65:	H2C_8710B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
./include/rtl8710b_cmd.h:66:	H2C_8710B_P2P_OFFLOAD = 0x8B,
./include/rtl8710b_cmd.h:159:#ifdef CONFIG_P2P
./include/rtl8710b_cmd.h:161:#endif /* CONFIG_P2P */
./include/rtl8710b_cmd.h:169:#ifdef CONFIG_P2P_WOWLAN
./include/rtl8723b_cmd.h:41:	H2C_8723B_P2P_LPS_PARAM = 0x23,
./include/rtl8723b_cmd.h:42:	H2C_8723B_P2P_PS_OFFLOAD = 0x24,
./include/rtl8723b_cmd.h:79:	H2C_8723B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
./include/rtl8723b_cmd.h:80:	H2C_8723B_P2P_OFFLOAD = 0x8B,
./include/rtl8723b_cmd.h:187:#ifdef CONFIG_P2P
./include/rtl8723b_cmd.h:189:#endif /* CONFIG_P2P */
./include/rtl8723b_cmd.h:197:#ifdef CONFIG_P2P_WOWLAN
./include/rtl8723d_cmd.h:41:	H2C_8723D_P2P_LPS_PARAM = 0x23,
./include/rtl8723d_cmd.h:42:	H2C_8723D_P2P_PS_OFFLOAD = 0x24,
./include/rtl8723d_cmd.h:79:	H2C_8723D_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
./include/rtl8723d_cmd.h:80:	H2C_8723D_P2P_OFFLOAD = 0x8B,
./include/rtl8723d_cmd.h:173:#ifdef CONFIG_P2P
./include/rtl8723d_cmd.h:175:#endif /* CONFIG_P2P */
./include/rtl8723d_cmd.h:183:#ifdef CONFIG_P2P_WOWLAN
./include/rtl8812a_cmd.h:34:	H2C_8812_P2P_PS_OFFLOAD = 0x24,
./include/rtl8812a_cmd.h:90:/* _P2P_PS_OFFLOAD */
./include/rtl8812a_cmd.h:91:#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
./include/rtl8812a_cmd.h:92:#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
./include/rtl8812a_cmd.h:93:#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
./include/rtl8812a_cmd.h:94:#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
./include/rtl8812a_cmd.h:95:#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
./include/rtl8812a_cmd.h:96:#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
./include/rtl8812a_cmd.h:97:#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
./include/rtl8812a_cmd.h:113:#ifdef CONFIG_P2P_PS
./include/rtl8812a_cmd.h:115:#endif /* CONFIG_P2P */
./include/rtl8814a_cmd.h:128:/* _P2P_PS_OFFLOAD */
./include/rtl8814a_cmd.h:129:#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
./include/rtl8814a_cmd.h:130:#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
./include/rtl8814a_cmd.h:131:#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
./include/rtl8814a_cmd.h:132:#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
./include/rtl8814a_cmd.h:133:#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
./include/rtl8814a_cmd.h:134:#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
./include/rtl8814a_cmd.h:135:#define SET_8814A_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
./include/rtl8814a_cmd.h:161:#ifdef CONFIG_P2P_PS
./include/rtl8814a_cmd.h:163:#endif /* CONFIG_P2P */
./include/rtl8814a_spec.h:378:#define REG_P2P_RST_8814A				0x05F0
./include/rtw_android.h:35:	ANDROID_WIFI_CMD_P2P_DEV_ADDR,
./include/rtw_android.h:40:	ANDROID_WIFI_CMD_P2P_SET_NOA,
./include/rtw_android.h:41:	ANDROID_WIFI_CMD_P2P_GET_NOA,
./include/rtw_android.h:42:	ANDROID_WIFI_CMD_P2P_SET_PS,
./include/rtw_android.h:43:	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
./include/rtw_android.h:72:	ANDROID_WIFI_CMD_P2P_DISABLE,
./include/rtw_cmd.h:135:struct P2P_PS_Offload_t {
./include/rtw_cmd.h:144:#ifdef CONFIG_P2P_PS_NOA_USE_MACID_SLEEP
./include/rtw_cmd.h:147:#endif /* CONFIG_P2P_PS_NOA_USE_MACID_SLEEP */
./include/rtw_cmd.h:150:struct P2P_PS_CTWPeriod_t {
./include/rtw_cmd.h:154:#ifdef CONFIG_P2P_WOWLAN
./include/rtw_cmd.h:156:struct P2P_WoWlan_Offload_t {
./include/rtw_cmd.h:162:#endif /* CONFIG_P2P_WOWLAN */
./include/rtw_cmd.h:184:#ifdef CONFIG_P2P
./include/rtw_cmd.h:205:#endif /* CONFIG_P2P */
./include/rtw_cmd.h:227:	P2P_PS_WK_CID,
./include/rtw_cmd.h:228:	P2P_PROTO_WK_CID,
./include/rtw_mcc.h:157:	MCC_FAVOR_P2P = 2,
./include/rtw_mcc.h:190:	u8 p2p_go_noa_ie[MAX_P2P_IE_LEN];
./include/rtw_rf.h:61:	cIBSS			= 0x0002,
./include/wifi.h:55:#ifdef CONFIG_P2P
./include/wifi.h:56:#define WIFI_P2P_PROBEREQ_VENDOR_IE_BIT BIT(5)
./include/wifi.h:57:#define WIFI_P2P_PROBERESP_VENDOR_IE_BIT BIT(6)
./include/wifi.h:600:#define _IBSS_PARA_IE_			6
./include/wifi.h:644:	EID_IbssParms				= 6, /* IBSS parameter set (2) */
./include/wifi.h:736:#define cap_IBSS BIT(1)
./include/wifi.h:1100:/*	=====================P2P Section===================== */
./include/wifi.h:1101:/*	For P2P */
./include/wifi.h:1102:#define	P2POUI							0x506F9A09
./include/wifi.h:1104:/*	P2P Attribute ID */
./include/wifi.h:1105:#define	P2P_ATTR_STATUS					0x00
./include/wifi.h:1106:#define	P2P_ATTR_MINOR_REASON_CODE		0x01
./include/wifi.h:1107:#define	P2P_ATTR_CAPABILITY				0x02
./include/wifi.h:1108:#define	P2P_ATTR_DEVICE_ID				0x03
./include/wifi.h:1109:#define	P2P_ATTR_GO_INTENT				0x04
./include/wifi.h:1110:#define	P2P_ATTR_CONF_TIMEOUT			0x05
./include/wifi.h:1111:#define	P2P_ATTR_LISTEN_CH				0x06
./include/wifi.h:1112:#define	P2P_ATTR_GROUP_BSSID				0x07
./include/wifi.h:1113:#define	P2P_ATTR_EX_LISTEN_TIMING		0x08
./include/wifi.h:1114:#define	P2P_ATTR_INTENDED_IF_ADDR		0x09
./include/wifi.h:1115:#define	P2P_ATTR_MANAGEABILITY			0x0A
./include/wifi.h:1116:#define	P2P_ATTR_CH_LIST					0x0B
./include/wifi.h:1117:#define	P2P_ATTR_NOA						0x0C
./include/wifi.h:1118:#define	P2P_ATTR_DEVICE_INFO				0x0D
./include/wifi.h:1119:#define	P2P_ATTR_GROUP_INFO				0x0E
./include/wifi.h:1120:#define	P2P_ATTR_GROUP_ID					0x0F
./include/wifi.h:1121:#define	P2P_ATTR_INTERFACE				0x10
./include/wifi.h:1122:#define	P2P_ATTR_OPERATING_CH			0x11
./include/wifi.h:1123:#define	P2P_ATTR_INVITATION_FLAGS		0x12
./include/wifi.h:1126:#define	P2P_STATUS_SUCCESS						0x00
./include/wifi.h:1127:#define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
./include/wifi.h:1128:#define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
./include/wifi.h:1129:#define	P2P_STATUS_FAIL_LIMIT_REACHED			0x03
./include/wifi.h:1130:#define	P2P_STATUS_FAIL_INVALID_PARAM			0x04
./include/wifi.h:1131:#define	P2P_STATUS_FAIL_REQUEST_UNABLE			0x05
./include/wifi.h:1132:#define	P2P_STATUS_FAIL_PREVOUS_PROTO_ERR		0x06
./include/wifi.h:1133:#define	P2P_STATUS_FAIL_NO_COMMON_CH			0x07
./include/wifi.h:1134:#define	P2P_STATUS_FAIL_UNKNOWN_P2PGROUP		0x08
./include/wifi.h:1135:#define	P2P_STATUS_FAIL_BOTH_GOINTENT_15		0x09
./include/wifi.h:1136:#define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
./include/wifi.h:1137:#define	P2P_STATUS_FAIL_USER_REJECT				0x0B
./include/wifi.h:1140:#define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)
./include/wifi.h:1142:#define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
./include/wifi.h:1143:				 P2P_DEVCAP_CLIENT_DISCOVERABILITY | \
./include/wifi.h:1144:				 P2P_DEVCAP_CONCURRENT_OPERATION | \
./include/wifi.h:1145:				 P2P_DEVCAP_INVITATION_PROC)
./include/wifi.h:1147:#define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)
./include/wifi.h:1150:#define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
./include/wifi.h:1151:#define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
./include/wifi.h:1152:#define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
./include/wifi.h:1153:#define	P2P_DEVCAP_INFRA_MANAGED			BIT(3)
./include/wifi.h:1154:#define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
./include/wifi.h:1155:#define	P2P_DEVCAP_INVITATION_PROC			BIT(5)
./include/wifi.h:1158:#define	P2P_GRPCAP_GO							BIT(0)
./include/wifi.h:1159:#define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
./include/wifi.h:1160:#define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
./include/wifi.h:1161:#define	P2P_GRPCAP_INTRABSS					BIT(3)
./include/wifi.h:1162:#define	P2P_GRPCAP_CROSS_CONN				BIT(4)
./include/wifi.h:1163:#define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
./include/wifi.h:1164:#define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
./include/wifi.h:1166:/*	P2P Public Action Frame ( Management Frame ) */
./include/wifi.h:1167:#define	P2P_PUB_ACTION_ACTION				0x09
./include/wifi.h:1169:/*	P2P Public Action Frame Type */
./include/wifi.h:1170:#define	P2P_GO_NEGO_REQ						0
./include/wifi.h:1171:#define	P2P_GO_NEGO_RESP						1
./include/wifi.h:1172:#define	P2P_GO_NEGO_CONF						2
./include/wifi.h:1173:#define	P2P_INVIT_REQ							3
./include/wifi.h:1174:#define	P2P_INVIT_RESP							4
./include/wifi.h:1175:#define	P2P_DEVDISC_REQ						5
./include/wifi.h:1176:#define	P2P_DEVDISC_RESP						6
./include/wifi.h:1177:#define	P2P_PROVISION_DISC_REQ				7
./include/wifi.h:1178:#define	P2P_PROVISION_DISC_RESP				8
./include/wifi.h:1180:/*	P2P Action Frame Type */
./include/wifi.h:1181:#define	P2P_NOTICE_OF_ABSENCE	0
./include/wifi.h:1182:#define	P2P_PRESENCE_REQUEST		1
./include/wifi.h:1183:#define	P2P_PRESENCE_RESPONSE	2
./include/wifi.h:1184:#define	P2P_GO_DISC_REQUEST		3
./include/wifi.h:1187:#define	P2P_MAX_PERSISTENT_GROUP_NUM		10
./include/wifi.h:1189:#define	P2P_PROVISIONING_SCAN_CNT			3
./include/wifi.h:1191:#define	P2P_WILDCARD_SSID_LEN				7
./include/wifi.h:1193:#define	P2P_FINDPHASE_EX_NONE				0	/* default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase */
./include/wifi.h:1194:#define	P2P_FINDPHASE_EX_FULL				1	/* used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase */
./include/wifi.h:1195:#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
./include/wifi.h:1196:#define	P2P_FINDPHASE_EX_MAX					4
./include/wifi.h:1197:#define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
./include/wifi.h:1199:#define	P2P_PROVISION_TIMEOUT				5000	/*	5 seconds timeout for sending the provision discovery request */
./include/wifi.h:1200:#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	/*	3 seconds timeout for sending the provision discovery request under concurrent mode */
./include/wifi.h:1201:#define	P2P_GO_NEGO_TIMEOUT					5000	/*	5 seconds timeout for receiving the group negotation response */
./include/wifi.h:1202:#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	/*	3 seconds timeout for sending the negotiation request under concurrent mode */
./include/wifi.h:1203:#define	P2P_TX_PRESCAN_TIMEOUT				100		/*	100ms */
./include/wifi.h:1204:#define	P2P_INVITE_TIMEOUT					5000	/*	5 seconds timeout for sending the invitation request */
./include/wifi.h:1205:#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	/*	3 seconds timeout for sending the invitation request under concurrent mode */
./include/wifi.h:1206:#define	P2P_RESET_SCAN_CH						25000	/*	25 seconds timeout to reset the scan channel (based on channel plan) */
./include/wifi.h:1207:#define	P2P_MAX_INTENT						15
./include/wifi.h:1209:#define	P2P_MAX_NOA_NUM						2
./include/wifi.h:1225:enum P2P_ROLE {
./include/wifi.h:1226:	P2P_ROLE_DISABLE = 0,
./include/wifi.h:1227:	P2P_ROLE_DEVICE = 1,
./include/wifi.h:1228:	P2P_ROLE_CLIENT = 2,
./include/wifi.h:1229:	P2P_ROLE_GO = 3
./include/wifi.h:1232:enum P2P_STATE {
./include/wifi.h:1233:	P2P_STATE_NONE = 0,							/*	P2P disable */
./include/wifi.h:1234:	P2P_STATE_IDLE = 1,								/*	P2P had enabled and do nothing ,  buddy adapters is linked */
./include/wifi.h:1235:	P2P_STATE_LISTEN = 2,							/*	In pure listen state */
./include/wifi.h:1236:	P2P_STATE_SCAN = 3,							/*	In scan phase */
./include/wifi.h:1237:	P2P_STATE_FIND_PHASE_LISTEN = 4,				/*	In the listen state of find phase */
./include/wifi.h:1238:	P2P_STATE_FIND_PHASE_SEARCH = 5,				/*	In the search state of find phase */
./include/wifi.h:1239:	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			/*	In P2P provisioning discovery */
./include/wifi.h:1240:	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
./include/wifi.h:1241:	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
./include/wifi.h:1242:	P2P_STATE_GONEGO_ING = 9,						/*	Doing the group owner negoitation handshake */
./include/wifi.h:1243:	P2P_STATE_GONEGO_OK = 10,						/*	finish the group negoitation handshake with success */
./include/wifi.h:1244:	P2P_STATE_GONEGO_FAIL = 11,					/*	finish the group negoitation handshake with failure */
./include/wifi.h:1245:	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		/*	receiving the P2P Inviation request and match with the profile. */
./include/wifi.h:1246:	P2P_STATE_PROVISIONING_ING = 13,				/*	Doing the P2P WPS */
./include/wifi.h:1247:	P2P_STATE_PROVISIONING_DONE = 14,			/*	Finish the P2P WPS */
./include/wifi.h:1248:	P2P_STATE_TX_INVITE_REQ = 15,					/*	Transmit the P2P Invitation request */
./include/wifi.h:1249:	P2P_STATE_RX_INVITE_RESP_OK = 16,				/*	Receiving the P2P Invitation response */
./include/wifi.h:1250:	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	/*	receiving the P2P Inviation request and dismatch with the profile. */
./include/wifi.h:1251:	P2P_STATE_RECV_INVITE_REQ_GO = 18,			/*	receiving the P2P Inviation request and this wifi is GO. */
./include/wifi.h:1252:	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			/*	receiving the P2P Inviation request to join an existing P2P Group. */
./include/wifi.h:1253:	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			/*	recveing the P2P Inviation response with failure */
./include/wifi.h:1254:	P2P_STATE_RX_INFOR_NOREADY = 21,			/* receiving p2p negoitation response with information is not available */
./include/wifi.h:1255:	P2P_STATE_TX_INFOR_NOREADY = 22,			/* sending p2p negoitation response with information is not available */
./include/wifi.h:1258:enum P2P_WPSINFO {
./include/wifi.h:1259:	P2P_NO_WPSINFO						= 0,
./include/wifi.h:1260:	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN	= 1,
./include/wifi.h:1261:	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN	= 2,
./include/wifi.h:1262:	P2P_GOT_WPSINFO_PBC					= 3,
./include/wifi.h:1265:#define	P2P_PRIVATE_IOCTL_SET_LEN		64
./include/wifi.h:1267:enum P2P_PROTO_WK_ID {
./include/wifi.h:1268:	P2P_FIND_PHASE_WK = 0,
./include/wifi.h:1269:	P2P_RESTORE_STATE_WK = 1,
./include/wifi.h:1270:	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
./include/wifi.h:1271:	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
./include/wifi.h:1272:	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
./include/wifi.h:1273:	P2P_AP_P2P_CH_SWITCH_PROCESS_WK = 5,
./include/wifi.h:1274:	P2P_RO_CH_WK = 6,
./include/wifi.h:1275:	P2P_CANCEL_RO_CH_WK = 7,
./include/wifi.h:1278:#ifdef CONFIG_P2P_PS
./include/wifi.h:1279:enum P2P_PS_STATE {
./include/wifi.h:1280:	P2P_PS_DISABLE = 0,
./include/wifi.h:1281:	P2P_PS_ENABLE = 1,
./include/wifi.h:1282:	P2P_PS_SCAN = 2,
./include/wifi.h:1283:	P2P_PS_SCAN_DONE = 3,
./include/wifi.h:1284:	P2P_PS_ALLSTASLEEP = 4, /* for P2P GO */
./include/wifi.h:1287:enum P2P_PS_MODE {
./include/wifi.h:1288:	P2P_PS_NONE = 0,
./include/wifi.h:1289:	P2P_PS_CTWINDOW = 1,
./include/wifi.h:1290:	P2P_PS_NOA	 = 2,
./include/wifi.h:1291:	P2P_PS_MIX = 3, /* CTWindow and NoA */
./include/wifi.h:1293:#endif /* CONFIG_P2P_PS */
./include/rtw_mlme.h:91:#ifdef CONFIG_P2P
./include/rtw_mlme.h:92:	#define MLME_IS_PD(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_DEVICE)
./include/rtw_mlme.h:93:	#define MLME_IS_GC(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_CLIENT)
./include/rtw_mlme.h:94:	#define MLME_IS_GO(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_GO)
./include/rtw_mlme.h:95:#else /* !CONFIG_P2P */
./include/rtw_mlme.h:99:#endif /* !CONFIG_P2P */
./include/rtw_mlme.h:110:#if defined(CONFIG_IOCTL_CFG80211) && defined(CONFIG_P2P)
./include/rtw_mlme.h:197:	SCAN_RESULT_P2P_ONLY = 0,		/*	Will return all the P2P devices. */
./include/rtw_mlme.h:251:	u8					peer_ch;		/*	The listen channel for peer P2P device */
./include/rtw_mlme.h:275:													/*	0 -> Prefer to use the P2P for WFD connection on peer side. */
./include/rtw_mlme.h:281:	enum	SCAN_RESULT_TYPE	scan_result_type;	/*	Used when P2P is enable. This parameter will impact the scan result. */
./include/rtw_mlme.h:306:	u8					peer_ch;					/*	The listen channel for peer P2P device */
./include/rtw_mlme.h:310:	u8					go_device_addr[ETH_ALEN];	/*	The GO's device address of this P2P group */
./include/rtw_mlme.h:311:	u8					ssid[WLAN_SSID_MAXLEN];		/*	The SSID of this P2P group */
./include/rtw_mlme.h:316:#ifndef CONFIG_P2P_OP_CHK_SOCIAL_CH
./include/rtw_mlme.h:320:#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
./include/rtw_mlme.h:337:#ifdef CONFIG_P2P_WOWLAN
./include/rtw_mlme.h:339:enum P2P_WOWLAN_RECV_FRAME_TYPE {
./include/rtw_mlme.h:340:	P2P_WOWLAN_RECV_NEGO_REQ = 0,
./include/rtw_mlme.h:341:	P2P_WOWLAN_RECV_INVITE_REQ = 1,
./include/rtw_mlme.h:342:	P2P_WOWLAN_RECV_PROVISION_REQ = 2,
./include/rtw_mlme.h:348:	enum P2P_WOWLAN_RECV_FRAME_TYPE	wowlan_recv_frame_type;
./include/rtw_mlme.h:355:#endif /* CONFIG_P2P_WOWLAN */
./include/rtw_mlme.h:362:	/*	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer. */
./include/rtw_mlme.h:373:	struct profile_info			profileinfo[P2P_MAX_PERSISTENT_GROUP_NUM];	/*	Store the profile information of persistent group */
./include/rtw_mlme.h:378:	struct scan_limit_info		p2p_info;		/*	Used for get the limit scan channel from the P2P negotiation handshake */
./include/rtw_mlme.h:383:#ifdef CONFIG_P2P_WOWLAN
./include/rtw_mlme.h:385:#endif /* CONFIG_P2P_WOWLAN */
./include/rtw_mlme.h:387:	enum P2P_ROLE			role;
./include/rtw_mlme.h:388:	enum P2P_STATE			pre_p2p_state;
./include/rtw_mlme.h:389:	enum P2P_STATE			p2p_state;
./include/rtw_mlme.h:397:	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
./include/rtw_mlme.h:432:	enum	P2P_WPSINFO		ui_got_wps_info;			/*	This field will store the WPS value (PIN value or PBC) that UI had got from the user. */
./include/rtw_mlme.h:437:	uint						channel_list_attr_len;	/*	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame. */
./include/rtw_mlme.h:438:	u8						channel_list_attr[100];		/*	This field will contain the body of P2P Channel List attribute of group negotitation response frame. */
./include/rtw_mlme.h:444:	u16						ext_listen_period;	/*	The time period to be available for P2P listen state (ms) */
./include/rtw_mlme.h:446:#ifdef CONFIG_P2P_PS
./include/rtw_mlme.h:447:	enum P2P_PS_MODE		p2p_ps_mode; /* indicate p2p ps mode */
./include/rtw_mlme.h:448:	enum P2P_PS_STATE		p2p_ps_state; /* indicate p2p ps state */
./include/rtw_mlme.h:452:	u8						noa_num; /* number of NoA descriptor in P2P IE. */
./include/rtw_mlme.h:453:	u8						noa_count[P2P_MAX_NOA_NUM]; /* Count for owner, Type of client. */
./include/rtw_mlme.h:454:	u32						noa_duration[P2P_MAX_NOA_NUM]; /* Max duration for owner, preferred or min acceptable duration for client. */
./include/rtw_mlme.h:455:	u32						noa_interval[P2P_MAX_NOA_NUM]; /* Length of interval for owner, preferred or max acceptable interval of client. */
./include/rtw_mlme.h:456:	u32						noa_start_time[P2P_MAX_NOA_NUM]; /* schedule expressed in terms of the lower 4 bytes of the TSF timer. */
./include/rtw_mlme.h:457:#endif /* CONFIG_P2P_PS */
./include/rtw_pwrctrl.h:85:	PS_MODE_IBSS			,
./include/rtw_beamforming.h:96:	/* Used to Set Reg42C in IBSS mode */
./include/rtw_mi.h:48:	#ifdef CONFIG_P2P
./include/rtw_mi.h:53:#ifdef CONFIG_P2P
./include/rtw_mi.h:98:#if defined(CONFIG_IOCTL_CFG80211) && defined(CONFIG_P2P)
./include/rtw_mi.h:104:#ifdef CONFIG_P2P
./include/rtw_mi.h:105:#define MSTATE_P2P_DV_NUM(_mstate)		((_mstate)->p2p_device_num)
./include/rtw_mi.h:106:#define MSTATE_P2P_GC_NUM(_mstate)		((_mstate)->p2p_gc)
./include/rtw_mi.h:107:#define MSTATE_P2P_GO_NUM(_mstate)		((_mstate)->p2p_go)
./include/rtw_mi.h:109:#define MSTATE_P2P_DV_NUM(_mstate)		0
./include/rtw_mi.h:110:#define MSTATE_P2P_GC_NUM(_mstate)		0
./include/rtw_mi.h:111:#define MSTATE_P2P_GO_NUM(_mstate)		0
./include/rtw_mi.h:283:#ifdef CONFIG_P2P
./include/rtw_mi.h:284:u8 rtw_mi_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state);
./include/rtw_mi.h:285:u8 rtw_mi_buddy_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state);
./include/rtw_mlme_ext.h:86:extern unsigned char P2P_OUI[];
./include/rtw_mlme_ext.h:177:	SCAN_TO_P2P_LISTEN = 10,
./include/rtw_mlme_ext.h:178:	SCAN_P2P_LISTEN = 11,
./include/rtw_mlme_ext.h:451:/* P2P_MAX_REG_CLASSES - Maximum number of regulatory classes */
./include/rtw_mlme_ext.h:452:#define P2P_MAX_REG_CLASSES 10
./include/rtw_mlme_ext.h:454:/* P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class */
./include/rtw_mlme_ext.h:455:#define P2P_MAX_REG_CLASS_CHANNELS 20
./include/rtw_mlme_ext.h:465:		u8 channel[P2P_MAX_REG_CLASS_CHANNELS];
./include/rtw_mlme_ext.h:469:	} reg_class[P2P_MAX_REG_CLASSES];
./include/rtw_mlme_ext.h:729:int is_IBSS_empty(_adapter *padapter);
./include/rtw_mlme_ext.h:884:#ifdef CONFIG_P2P
./include/rtw_mlme_ext.h:893:#endif /* CONFIG_P2P */
./include/wlan_bssdef.h:50:	Ndis802_11IBSS,
./include/wlan_bssdef.h:137:	Ndis802_11IBSS,
./include/rtw_debug.h:502:#ifdef CONFIG_P2P_WOWLAN
./include/rtw_debug.h:504:#endif /* CONFIG_P2P_WOWLAN */
./include/rtw_p2p.h:15:#ifndef __RTW_P2P_H_
./include/rtw_p2p.h:16:#define __RTW_P2P_H_
./include/rtw_p2p.h:66:#ifdef CONFIG_P2P_PS
./include/rtw_p2p.h:70:#endif /* CONFIG_P2P_PS */
./include/rtw_p2p.h:81:void init_wifidirect_info(_adapter *padapter, enum P2P_ROLE role);
./include/rtw_p2p.h:82:int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role);
./include/rtw_p2p.h:84:static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
./include/rtw_p2p.h:91:static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
./include/rtw_p2p.h:105:void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role);
./include/rtw_p2p.h:119:static inline bool _rtw_p2p_chk_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
./include/rtw_p2p.h:123:static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
./include/rtw_p2p.h:128:#ifdef CONFIG_DBG_P2P
./include/rtw_p2p.h:129:void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
./include/rtw_p2p.h:130:void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
./include/rtw_p2p.h:132:void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line);
./include/rtw_p2p.h:137:#else /* CONFIG_DBG_P2P */
./include/rtw_p2p.h:142:#endif /* CONFIG_DBG_P2P */
./include/rtw_p2p.h:153:#ifdef CONFIG_P2P
./include/rtw_p2p.h:156:	(wdinfo)->find_phase_state_exchange_cnt >= P2P_FINDPHASE_EX_SOCIAL_FIRST
./include/rtw_p2p.h:160:	((wdinfo)->find_phase_state_exchange_cnt < P2P_FINDPHASE_EX_MAX && \
./include/rtw_p2p.h:161:	 (wdinfo)->find_phase_state_exchange_cnt != P2P_FINDPHASE_EX_NONE && \
./include/rtw_p2p.h:167:#endif /* CONFIG_P2P */
./include/sta_info.h:20:#define IBSS_START_MAC_ID	2
./include/sta_info.h:436:#ifdef CONFIG_P2P
./include/sta_info.h:451:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:568:	[NL80211_IFTYPE_P2P_CLIENT] = {
./os_dep/linux/ioctl_cfg80211.c:573:	[NL80211_IFTYPE_P2P_GO] = {
./os_dep/linux/ioctl_cfg80211.c:583:#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:584:	[NL80211_IFTYPE_P2P_DEVICE] = {
./os_dep/linux/ioctl_cfg80211.c:605:		return Ndis802_11IBSS;
./os_dep/linux/ioctl_cfg80211.c:607:	#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:608:	case NL80211_IFTYPE_P2P_CLIENT:
./os_dep/linux/ioctl_cfg80211.c:614:	#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:615:	case NL80211_IFTYPE_P2P_GO:
./os_dep/linux/ioctl_cfg80211.c:640:	#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:641:	case NL80211_IFTYPE_P2P_CLIENT:
./os_dep/linux/ioctl_cfg80211.c:647:	#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:648:	case NL80211_IFTYPE_P2P_GO:
./os_dep/linux/ioctl_cfg80211.c:850:	#if defined(CONFIG_P2P) && 0
./os_dep/linux/ioctl_cfg80211.c:929:			pnetwork->InfrastructureMode == Ndis802_11Infrastructure?IEEE80211_BSS_TYPE_ESS:IEEE80211_BSS_TYPE_IBSS,
./os_dep/linux/ioctl_cfg80211.c:932:			pnetwork->InfrastructureMode == Ndis802_11Infrastructure?WLAN_CAPABILITY_ESS:WLAN_CAPABILITY_IBSS, pnetwork->InfrastructureMode == Ndis802_11Infrastructure?WLAN_CAPABILITY_ESS:WLAN_CAPABILITY_IBSS);
./os_dep/linux/ioctl_cfg80211.c:997:	/* notify cfg80211 that device joined an IBSS */
./os_dep/linux/ioctl_cfg80211.c:1016:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:1026:		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
./os_dep/linux/ioctl_cfg80211.c:1034:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:1036:		#if !RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:1037:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_cfg80211.c:1039:			rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
./os_dep/linux/ioctl_cfg80211.c:1040:			rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./os_dep/linux/ioctl_cfg80211.c:1045:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:1150:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:1162:		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
./os_dep/linux/ioctl_cfg80211.c:1170:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:1172:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_cfg80211.c:1175:			#if RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:1177:			if (pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)
./os_dep/linux/ioctl_cfg80211.c:1180:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./os_dep/linux/ioctl_cfg80211.c:1185:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:1484:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:1486:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:1618:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:1620:						if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
./os_dep/linux/ioctl_cfg80211.c:1621:							rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
./os_dep/linux/ioctl_cfg80211.c:1623:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:2251:	/* for infra./P2PClient mode */
./os_dep/linux/ioctl_cfg80211.c:2308:	NL80211_IFTYPE_P2P_CLIENT, /* 8 */
./os_dep/linux/ioctl_cfg80211.c:2309:	NL80211_IFTYPE_P2P_GO, /* 9 */
./os_dep/linux/ioctl_cfg80211.c:2328:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:2387:		networkType = Ndis802_11IBSS;
./os_dep/linux/ioctl_cfg80211.c:2390:	#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:2391:	case NL80211_IFTYPE_P2P_CLIENT:
./os_dep/linux/ioctl_cfg80211.c:2398:		#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:2401:				rtw_p2p_enable(padapter, P2P_ROLE_CLIENT);
./os_dep/linux/ioctl_cfg80211.c:2402:			#if !RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:2403:			else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)
./os_dep/linux/ioctl_cfg80211.c:2404:					|| rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
./os_dep/linux/ioctl_cfg80211.c:2406:				/* it means remove GC/GO and change mode from GC/GO to station(P2P DEVICE) */
./os_dep/linux/ioctl_cfg80211.c:2407:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
./os_dep/linux/ioctl_cfg80211.c:2411:		#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:2415:	#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:2416:	case NL80211_IFTYPE_P2P_GO:
./os_dep/linux/ioctl_cfg80211.c:2423:		#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:2426:				rtw_p2p_enable(padapter, P2P_ROLE_GO);
./os_dep/linux/ioctl_cfg80211.c:2427:			#if !RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:2428:			else if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_cfg80211.c:2429:				/* it means P2P Group created, we will be GO and change mode from  P2P DEVICE to AP(GO) */
./os_dep/linux/ioctl_cfg80211.c:2430:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./os_dep/linux/ioctl_cfg80211.c:2434:		#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:2554:		select_network.InfrastructureMode == Ndis802_11Infrastructure?IEEE80211_BSS_TYPE_ESS:IEEE80211_BSS_TYPE_IBSS,
./os_dep/linux/ioctl_cfg80211.c:2557:		select_network.InfrastructureMode == Ndis802_11Infrastructure?WLAN_CAPABILITY_ESS:WLAN_CAPABILITY_IBSS,
./os_dep/linux/ioctl_cfg80211.c:2558:		select_network.InfrastructureMode == Ndis802_11Infrastructure?WLAN_CAPABILITY_ESS:WLAN_CAPABILITY_IBSS);
./os_dep/linux/ioctl_cfg80211.c:2708:		#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:2735:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, (u8 *)listen_ch_attr, (uint *) &attr_contentlen)
./os_dep/linux/ioctl_cfg80211.c:2745:		#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:2878:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:2880:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:2884:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:2906:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:2908:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:2922:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:2928:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./os_dep/linux/ioctl_cfg80211.c:2929:				rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
./os_dep/linux/ioctl_cfg80211.c:2936:			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
./os_dep/linux/ioctl_cfg80211.c:2946:#endif /*CONFIG_P2P*/
./os_dep/linux/ioctl_cfg80211.c:3031:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:3037:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./os_dep/linux/ioctl_cfg80211.c:3038:				rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
./os_dep/linux/ioctl_cfg80211.c:3045:			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
./os_dep/linux/ioctl_cfg80211.c:3055:#endif /*CONFIG_P2P*/
./os_dep/linux/ioctl_cfg80211.c:3143:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:3144:	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {
./os_dep/linux/ioctl_cfg80211.c:3145:		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
./os_dep/linux/ioctl_cfg80211.c:3148:			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
./os_dep/linux/ioctl_cfg80211.c:3150:			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
./os_dep/linux/ioctl_cfg80211.c:3152:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:3448:	if (ielen > MAX_WPA_IE_LEN + MAX_WPS_IE_LEN + MAX_P2P_IE_LEN) {
./os_dep/linux/ioctl_cfg80211.c:3564:	#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:3592:	#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:3830:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:3832:		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./os_dep/linux/ioctl_cfg80211.c:3833:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:4489:		#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:4498:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:4518:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:4521:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:4698:#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:4699:	case NL80211_IFTYPE_P2P_CLIENT:
./os_dep/linux/ioctl_cfg80211.c:4700:	case NL80211_IFTYPE_P2P_GO:
./os_dep/linux/ioctl_cfg80211.c:4718:		#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:4719:		if (type == NL80211_IFTYPE_P2P_CLIENT || type == NL80211_IFTYPE_P2P_GO)
./os_dep/linux/ioctl_cfg80211.c:4720:			rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
./os_dep/linux/ioctl_cfg80211.c:4726:#if defined(CONFIG_P2P) && defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:4727:	case NL80211_IFTYPE_P2P_DEVICE:
./os_dep/linux/ioctl_cfg80211.c:4789:#if defined(CONFIG_P2P) && defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:4790:	if (wdev->iftype == NL80211_IFTYPE_P2P_DEVICE) {
./os_dep/linux/ioctl_cfg80211.c:4794:			RTW_ERR(FUNC_WIPHY_FMT" unknown P2P Device wdev:%p\n", FUNC_WIPHY_ARG(wiphy), wdev);
./os_dep/linux/ioctl_cfg80211.c:4856:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:4866:			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_cfg80211.c:4867:				RTW_INFO("Enable P2P function for the first time\n");
./os_dep/linux/ioctl_cfg80211.c:4868:				rtw_p2p_enable(adapter, P2P_ROLE_GO);
./os_dep/linux/ioctl_cfg80211.c:4874:				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
./os_dep/linux/ioctl_cfg80211.c:4875:				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
./os_dep/linux/ioctl_cfg80211.c:4880:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:4883:	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);
./os_dep/linux/ioctl_cfg80211.c:4887:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:4894:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:6084:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:6091:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:6118:	#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:6122:		case P2P_GO_NEGO_CONF:
./os_dep/linux/ioctl_cfg80211.c:6143:		case P2P_PROVISION_DISC_RESP:
./os_dep/linux/ioctl_cfg80211.c:6144:		case P2P_INVIT_RESP:
./os_dep/linux/ioctl_cfg80211.c:6146:			#if !RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:6156:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:6159:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:6271:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:6285:	u8			action = P2P_PUB_ACTION_ACTION;
./os_dep/linux/ioctl_cfg80211.c:6287:	u32			p2poui = cpu_to_be32(P2POUI);
./os_dep/linux/ioctl_cfg80211.c:6288:	u8			oui_subtype = P2P_PROVISION_DISC_REQ;
./os_dep/linux/ioctl_cfg80211.c:6343:		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, devinfo_content, &devinfo_contentlen);
./os_dep/linux/ioctl_cfg80211.c:6344:		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&capability, &capability_len);
./os_dep/linux/ioctl_cfg80211.c:6390:	/*	P2P OUI */
./os_dep/linux/ioctl_cfg80211.c:6395:	p2p_ie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
./os_dep/linux/ioctl_cfg80211.c:6398:	/*	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
./os_dep/linux/ioctl_cfg80211.c:6399:	/*	1. P2P Capability */
./os_dep/linux/ioctl_cfg80211.c:6401:	/*	3. Group ID ( When joining an operating P2P Group ) */
./os_dep/linux/ioctl_cfg80211.c:6403:	/*	P2P Capability ATTR */
./os_dep/linux/ioctl_cfg80211.c:6405:	p2p_ie[p2pielen++] = P2P_ATTR_CAPABILITY;
./os_dep/linux/ioctl_cfg80211.c:6421:	p2p_ie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
./os_dep/linux/ioctl_cfg80211.c:6424:	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
./os_dep/linux/ioctl_cfg80211.c:6587:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:6653:	/* if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) */
./os_dep/linux/ioctl_cfg80211.c:6654:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
./os_dep/linux/ioctl_cfg80211.c:6660:		rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
./os_dep/linux/ioctl_cfg80211.c:6664:	} else if (rtw_p2p_chk_state(pwdinfo , P2P_STATE_LISTEN)
./os_dep/linux/ioctl_cfg80211.c:6680:	rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
./os_dep/linux/ioctl_cfg80211.c:6729:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:6770:#if RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:6779:#if RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:6785:		return rtw_p2p_chk_state(wdinfo, P2P_STATE_SCAN)
./os_dep/linux/ioctl_cfg80211.c:6786:			|| rtw_p2p_chk_state(wdinfo, P2P_STATE_FIND_PHASE_SEARCH);
./os_dep/linux/ioctl_cfg80211.c:6789:#if RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:6790:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:6796:		* For 2 RTW_P2P_GROUP_INTERFACE cases:
./os_dep/linux/ioctl_cfg80211.c:6797:		* 1. RTW_DEDICATED_P2P_DEVICE defined but upper layer don't use pd_wdev or
./os_dep/linux/ioctl_cfg80211.c:6798:		* 2. RTW_DEDICATED_P2P_DEVICE not defined
./os_dep/linux/ioctl_cfg80211.c:6821:#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:6844:	wdev->iftype = NL80211_IFTYPE_P2P_DEVICE;
./os_dep/linux/ioctl_cfg80211.c:6895:	rtw_p2p_enable(adapter, P2P_ROLE_DEVICE);
./os_dep/linux/ioctl_cfg80211.c:6908:	rtw_p2p_enable(adapter, P2P_ROLE_DISABLE);
./os_dep/linux/ioctl_cfg80211.c:6941:#endif /* RTW_DEDICATED_P2P_DEVICE */
./os_dep/linux/ioctl_cfg80211.c:6942:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:6967:#if defined(RTW_ROCH_BACK_OP) && defined(CONFIG_P2P) && defined(CONFIG_CONCURRENT_MODE)
./os_dep/linux/ioctl_cfg80211.c:6974:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:6987:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:6996:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:7012:		#if defined(RTW_ROCH_BACK_OP) && defined(CONFIG_P2P) && defined(CONFIG_CONCURRENT_MODE)
./os_dep/linux/ioctl_cfg80211.c:7026:		#endif /* RTW_ROCH_BACK_OP && CONFIG_P2P && CONFIG_CONCURRENT_MODE */
./os_dep/linux/ioctl_cfg80211.c:7067:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:7069:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:7098:	#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:7199:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:7210:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:7305:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:7309:		no_cck = 1; /* force no CCK for P2P frames */
./os_dep/linux/ioctl_cfg80211.c:7366:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:7369:		case P2P_GO_NEGO_CONF:
./os_dep/linux/ioctl_cfg80211.c:7390:		case P2P_INVIT_RESP:
./os_dep/linux/ioctl_cfg80211.c:7397:				#if !RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.c:7405:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:8813:		#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:8838:		#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:8925:				if (wdev->iftype == NL80211_IFTYPE_P2P_GO) {
./os_dep/linux/ioctl_cfg80211.c:8942:		#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:8953:			/* Check P2P Capability ATTR */
./os_dep/linux/ioctl_cfg80211.c:8954:			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&cap_attr, (uint *) &attr_contentlen)) {
./os_dep/linux/ioctl_cfg80211.c:8956:				/* RTW_INFO( "[%s] Got P2P Capability Attr!!\n", __FUNCTION__ ); */
./os_dep/linux/ioctl_cfg80211.c:8963:					RTW_INFO("Got P2P Capability Attr, grp_cap=0x%x, is_GO\n", grp_cap);
./os_dep/linux/ioctl_cfg80211.c:9002:		#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:9096:		#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:9107:				#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:9306:			#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:9307:			| BIT(NL80211_IFTYPE_P2P_CLIENT)
./os_dep/linux/ioctl_cfg80211.c:9314:			#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:9315:			| BIT(NL80211_IFTYPE_P2P_GO)
./os_dep/linux/ioctl_cfg80211.c:9319:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:9322:		.types = BIT(NL80211_IFTYPE_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:9337:		#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:9374:#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
./os_dep/linux/ioctl_cfg80211.c:9375:								| BIT(NL80211_IFTYPE_P2P_CLIENT)
./os_dep/linux/ioctl_cfg80211.c:9376:								| BIT(NL80211_IFTYPE_P2P_GO)
./os_dep/linux/ioctl_cfg80211.c:9377:								#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:9378:								| BIT(NL80211_IFTYPE_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:9388:                wiphy->interface_modes &= ~(BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT));
./os_dep/linux/ioctl_cfg80211.c:9471:		| WIPHY_FLAG_IBSS_RSN
./os_dep/linux/ioctl_cfg80211.c:9740:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.c:9743:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.c:9747:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_cfg80211.c:9851:	#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.h:33:#ifndef RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.h:34:	#define RTW_P2P_GROUP_INTERFACE 0
./os_dep/linux/ioctl_cfg80211.h:38:* (RTW_P2P_GROUP_INTERFACE, RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.h:44:#if RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.h:54:	#ifndef RTW_DEDICATED_P2P_DEVICE
./os_dep/linux/ioctl_cfg80211.h:55:		#define RTW_DEDICATED_P2P_DEVICE
./os_dep/linux/ioctl_cfg80211.h:64:#if !defined(CONFIG_P2P) && RTW_P2P_GROUP_INTERFACE
./os_dep/linux/ioctl_cfg80211.h:65:	#error "RTW_P2P_GROUP_INTERFACE can't be enabled when CONFIG_P2P is disabled\n"
./os_dep/linux/ioctl_cfg80211.h:68:#if !RTW_P2P_GROUP_INTERFACE && defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.h:69:	#error "RTW_DEDICATED_P2P_DEVICE can't be enabled when RTW_P2P_GROUP_INTERFACE is disabled\n"
./os_dep/linux/ioctl_cfg80211.h:72:#if defined(RTW_DEDICATED_P2P_DEVICE) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
./os_dep/linux/ioctl_cfg80211.h:73:	#error "RTW_DEDICATED_P2P_DEVICE can't be enabled when kernel < 3.7.0\n"
./os_dep/linux/ioctl_cfg80211.h:225:#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.h:226:	struct wireless_dev *pd_wdev; /* P2P device wdev */
./os_dep/linux/ioctl_cfg80211.h:238:#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.h:294:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_cfg80211.h:303:#if defined(RTW_DEDICATED_P2P_DEVICE)
./os_dep/linux/ioctl_cfg80211.h:309:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:273:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:278:	} else if ((SCAN_RESULT_P2P_ONLY == pwdinfo->wfd_info->scan_result_type) ||
./os_dep/linux/ioctl_linux.c:282:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_linux.c:283:			u32	blnGotP2PIE = _FALSE;
./os_dep/linux/ioctl_linux.c:285:			/*	User is doing the P2P device discovery */
./os_dep/linux/ioctl_linux.c:286:			/*	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. */
./os_dep/linux/ioctl_linux.c:290:			if (_rtw_memcmp(pnetwork->network.Ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN)) {
./os_dep/linux/ioctl_linux.c:293:				/*	Verifying the P2P IE */
./os_dep/linux/ioctl_linux.c:295:					blnGotP2PIE = _TRUE;
./os_dep/linux/ioctl_linux.c:298:			if (blnGotP2PIE == _FALSE)
./os_dep/linux/ioctl_linux.c:339:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:387:	if (cap & (WLAN_CAPABILITY_IBSS | WLAN_CAPABILITY_BSS)) {
./os_dep/linux/ioctl_linux.c:871:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:873:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:1005:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:1006:					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
./os_dep/linux/ioctl_linux.c:1007:						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
./os_dep/linux/ioctl_linux.c:1008:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:1049:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:1051:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:1171:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:1172:					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
./os_dep/linux/ioctl_linux.c:1173:						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_ING);
./os_dep/linux/ioctl_linux.c:1174:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:1404:		networkType = Ndis802_11IBSS;
./os_dep/linux/ioctl_linux.c:1936:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:1938:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:2040:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:2041:	if (pwdinfo->p2p_state != P2P_STATE_NONE) {
./os_dep/linux/ioctl_linux.c:2043:		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
./os_dep/linux/ioctl_linux.c:2044:		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_FULL);
./os_dep/linux/ioctl_linux.c:2047:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:2192:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:2194:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:2206:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:2207:	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
./os_dep/linux/ioctl_linux.c:2210:		/*	P2P is disabled */
./os_dep/linux/ioctl_linux.c:2217:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:3873:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:3883:	enum P2P_ROLE init_role = P2P_ROLE_DISABLE;
./os_dep/linux/ioctl_linux.c:3886:		init_role = P2P_ROLE_DISABLE;
./os_dep/linux/ioctl_linux.c:3888:		init_role = P2P_ROLE_DEVICE;
./os_dep/linux/ioctl_linux.c:3890:		init_role = P2P_ROLE_CLIENT;
./os_dep/linux/ioctl_linux.c:3892:		init_role = P2P_ROLE_GO;
./os_dep/linux/ioctl_linux.c:3900:	if (init_role != P2P_ROLE_DISABLE) {
./os_dep/linux/ioctl_linux.c:3904:		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN)) {
./os_dep/linux/ioctl_linux.c:3912:		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {
./os_dep/linux/ioctl_linux.c:4056:	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_linux.c:4059:			_rtw_memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
./os_dep/linux/ioctl_linux.c:4062:			if (pwdinfo->profileindex >= P2P_MAX_PERSISTENT_GROUP_NUM)
./os_dep/linux/ioctl_linux.c:4112:	if (padapter->bShowGetP2PState) {
./os_dep/linux/ioctl_linux.c:4130: *	This config method description will show us which config method the remote P2P device is intented to use
./os_dep/linux/ioctl_linux.c:4292:	u8	attr_content_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
./os_dep/linux/ioctl_linux.c:4381:	pwdinfo->wfd_info->wfd_pc = _FALSE;	/*	Reset the WFD preferred connection to P2P */
./os_dep/linux/ioctl_linux.c:4422:	u8 go_devadd_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
./os_dep/linux/ioctl_linux.c:4444:			/*	Match the device address located in the P2P IE */
./os_dep/linux/ioctl_linux.c:4445:			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
./os_dep/linux/ioctl_linux.c:4450:					/*	The P2P Device ID attribute is included in the Beacon frame. */
./os_dep/linux/ioctl_linux.c:4451:					/*	The P2P Device Info attribute is included in the probe response frame. */
./os_dep/linux/ioctl_linux.c:4454:					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:4455:						/*	Handle the P2P Device ID attribute of Beacon first */
./os_dep/linux/ioctl_linux.c:4459:					} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:4460:						/*	Handle the P2P Device Info attribute of probe response */
./os_dep/linux/ioctl_linux.c:4465:					/* Get the next P2P IE */
./os_dep/linux/ioctl_linux.c:4507:	u8 dev_type_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };    /* +9 is for the str "dev_type=", we have to clear it at wrqu->data.pointer */
./os_dep/linux/ioctl_linux.c:4581:	u8 dev_name_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
./os_dep/linux/ioctl_linux.c:4652:	u8 inv_proc_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
./os_dep/linux/ioctl_linux.c:4655:	/*	The application wants to know P2P initation procedure is support or not. */
./os_dep/linux/ioctl_linux.c:4674:			/*	Match the device address located in the P2P IE */
./os_dep/linux/ioctl_linux.c:4675:			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
./os_dep/linux/ioctl_linux.c:4681:					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_CAPABILITY, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:4682:						/*	Handle the P2P capability attribute */
./os_dep/linux/ioctl_linux.c:4688:					/* Get the next P2P IE */
./os_dep/linux/ioctl_linux.c:4742:	if (pwdinfo->p2p_state == P2P_STATE_NONE) {
./os_dep/linux/ioctl_linux.c:4747:	if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO)
./os_dep/linux/ioctl_linux.c:4796:		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK) {
./os_dep/linux/ioctl_linux.c:4798:			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
./os_dep/linux/ioctl_linux.c:4802:		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
./os_dep/linux/ioctl_linux.c:4816:		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./os_dep/linux/ioctl_linux.c:4819:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_GO_NEGO_TIMEOUT);
./os_dep/linux/ioctl_linux.c:4821:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
./os_dep/linux/ioctl_linux.c:4823:		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
./os_dep/linux/ioctl_linux.c:4856:	/*	1. First information is the P2P device address which you want to send to.	 */
./os_dep/linux/ioctl_linux.c:4868:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_linux.c:4897:		/*	Match the device address located in the P2P IE */
./os_dep/linux/ioctl_linux.c:4898:		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
./os_dep/linux/ioctl_linux.c:4902:			/*	The P2P Device ID attribute is included in the Beacon frame. */
./os_dep/linux/ioctl_linux.c:4903:			/*	The P2P Device Info attribute is included in the probe response frame. */
./os_dep/linux/ioctl_linux.c:4905:			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:4906:				/*	Handle the P2P Device ID attribute of Beacon first */
./os_dep/linux/ioctl_linux.c:4911:			} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:4912:				/*	Handle the P2P Device Info attribute of probe response */
./os_dep/linux/ioctl_linux.c:4978:		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INVITE_REQ);
./os_dep/linux/ioctl_linux.c:4995:		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./os_dep/linux/ioctl_linux.c:4999:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_INVITE_TIMEOUT);
./os_dep/linux/ioctl_linux.c:5001:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
./os_dep/linux/ioctl_linux.c:5003:		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
./os_dep/linux/ioctl_linux.c:5031:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_linux.c:5132:	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/ioctl_linux.c:5152:		/*	Match the device address located in the P2P IE */
./os_dep/linux/ioctl_linux.c:5153:		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
./os_dep/linux/ioctl_linux.c:5157:			/*	The P2P Device ID attribute is included in the Beacon frame. */
./os_dep/linux/ioctl_linux.c:5158:			/*	The P2P Device Info attribute is included in the probe response frame. */
./os_dep/linux/ioctl_linux.c:5159:			printk("[%s] Got P2P IE\n", __FUNCTION__);
./os_dep/linux/ioctl_linux.c:5160:			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:5161:				/*	Handle the P2P Device ID attribute of Beacon first */
./os_dep/linux/ioctl_linux.c:5162:				printk("[%s] P2P_ATTR_DEVICE_ID\n", __FUNCTION__);
./os_dep/linux/ioctl_linux.c:5167:			} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:5168:				/*	Handle the P2P Device Info attribute of probe response */
./os_dep/linux/ioctl_linux.c:5169:				printk("[%s] P2P_ATTR_DEVICE_INFO\n", __FUNCTION__);
./os_dep/linux/ioctl_linux.c:5346:	if (pwdinfo->p2p_state == P2P_STATE_NONE) {
./os_dep/linux/ioctl_linux.c:5390:		/*	Match the device address located in the P2P IE */
./os_dep/linux/ioctl_linux.c:5391:		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
./os_dep/linux/ioctl_linux.c:5396:				/*	The P2P Device ID attribute is included in the Beacon frame. */
./os_dep/linux/ioctl_linux.c:5397:				/*	The P2P Device Info attribute is included in the probe response frame. */
./os_dep/linux/ioctl_linux.c:5399:				if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:5400:					/*	Handle the P2P Device ID attribute of Beacon first */
./os_dep/linux/ioctl_linux.c:5405:				} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
./os_dep/linux/ioctl_linux.c:5406:					/*	Handle the P2P Device Info attribute of probe response */
./os_dep/linux/ioctl_linux.c:5413:				/* Get the next P2P IE */
./os_dep/linux/ioctl_linux.c:5470:		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ);
./os_dep/linux/ioctl_linux.c:5472:		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
./os_dep/linux/ioctl_linux.c:5474:		else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
./os_dep/linux/ioctl_linux.c:5475:			_rtw_memcpy(pwdinfo->tx_prov_disc_info.ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
./os_dep/linux/ioctl_linux.c:5476:			pwdinfo->tx_prov_disc_info.ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
./os_dep/linux/ioctl_linux.c:5494:		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
./os_dep/linux/ioctl_linux.c:5498:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_PROVISION_TIMEOUT);
./os_dep/linux/ioctl_linux.c:5500:			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
./os_dep/linux/ioctl_linux.c:5502:		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
./os_dep/linux/ioctl_linux.c:5530:	/*	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo */
./os_dep/linux/ioctl_linux.c:5531:	/*	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device. */
./os_dep/linux/ioctl_linux.c:5532:	/*	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself. */
./os_dep/linux/ioctl_linux.c:5533:	/*	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC */
./os_dep/linux/ioctl_linux.c:5536:		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
./os_dep/linux/ioctl_linux.c:5538:		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PEER_DISPLAY_PIN;
./os_dep/linux/ioctl_linux.c:5540:		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_SELF_DISPLAY_PIN;
./os_dep/linux/ioctl_linux.c:5542:		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PBC;
./os_dep/linux/ioctl_linux.c:5544:		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
./os_dep/linux/ioctl_linux.c:5550:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:5557:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:5634:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:5645:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:5648:	if (padapter->bShowGetP2PState)
./os_dep/linux/ioctl_linux.c:5660:		/*	Get the P2P device address when receiving the provision discovery request frame. */
./os_dep/linux/ioctl_linux.c:5665:		/*	Get the P2P device address when receiving the P2P Invitation request frame. */
./os_dep/linux/ioctl_linux.c:5681:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:5694:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:5730:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:6535:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:6536:			RTW_INFO("turn %s the bShowGetP2PState Variable\n", (extra_arg == 1) ? "on" : "off");
./os_dep/linux/ioctl_linux.c:6537:			padapter->bShowGetP2PState = extra_arg;
./os_dep/linux/ioctl_linux.c:6538:#endif /* CONFIG_P2P */
./os_dep/linux/ioctl_linux.c:8258:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:8259:	if (vendor_ie_mask & WIFI_P2P_PROBEREQ_VENDOR_IE_BIT)
./os_dep/linux/ioctl_linux.c:8260:		pstring += sprintf(pstring , "[P2P_Probe Req]");
./os_dep/linux/ioctl_linux.c:8261:	if (vendor_ie_mask & WIFI_P2P_PROBERESP_VENDOR_IE_BIT)
./os_dep/linux/ioctl_linux.c:8262:		pstring += sprintf(pstring , "[P2P_Probe Resp]");
./os_dep/linux/ioctl_linux.c:8386:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:8387:	if (vendor_ie_mask & WIFI_P2P_PROBEREQ_VENDOR_IE_BIT)
./os_dep/linux/ioctl_linux.c:8388:		RTW_INFO("[%s] P2P Probe Req append vendor ie\n", __func__);
./os_dep/linux/ioctl_linux.c:8389:	if (vendor_ie_mask & WIFI_P2P_PROBERESP_VENDOR_IE_BIT)
./os_dep/linux/ioctl_linux.c:8390:		RTW_INFO("[%s] P2P Probe Resp append vendor ie\n", __func__);
./os_dep/linux/ioctl_linux.c:9826:#ifdef CONFIG_P2P
./os_dep/linux/ioctl_linux.c:11439:	networkType = Ndis802_11IBSS;
./os_dep/linux/os_intfs.c:33:int rtw_network_mode = Ndis802_11IBSS;/* Ndis802_11Infrastructure; */ /* infra, ad-hoc, auto */
./os_dep/linux/os_intfs.c:341:But Softap must be SHUT DOWN once P2P decide to set up connection and become a GO.*/
./os_dep/linux/os_intfs.c:342:#ifdef CONFIG_FULL_CH_IN_P2P_HANDSHAKE
./os_dep/linux/os_intfs.c:577:MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
./os_dep/linux/os_intfs.c:2193:#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:2194:	padapter->bShowGetP2PState = 1;
./os_dep/linux/os_intfs.c:2541:#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:2543:	init_wifidirect_info(padapter, P2P_ROLE_DISABLE);
./os_dep/linux/os_intfs.c:2552:#endif /* CONFIG_P2P */
./os_dep/linux/os_intfs.c:2697:#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:2699:#endif /* CONFIG_P2P */
./os_dep/linux/os_intfs.c:2733:	#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:2736:		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
./os_dep/linux/os_intfs.c:2743:			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
./os_dep/linux/os_intfs.c:2924:#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:2925:	if (!rtw_p2p_chk_role(&padapter->wdinfo, P2P_ROLE_DISABLE))
./os_dep/linux/os_intfs.c:2926:		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
./os_dep/linux/os_intfs.c:3048:#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:4024:#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:4025:	if (!rtw_p2p_chk_role(&padapter->wdinfo, P2P_ROLE_DISABLE))
./os_dep/linux/os_intfs.c:4026:		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
./os_dep/linux/os_intfs.c:4027:#endif /* CONFIG_P2P */
./os_dep/linux/os_intfs.c:4474:#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:4476:#endif /* CONFIG_P2P */
./os_dep/linux/os_intfs.c:4483:			#ifdef CONFIG_P2P
./os_dep/linux/os_intfs.c:4484:			&& (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
./os_dep/linux/os_intfs.c:4485:				#if defined(CONFIG_IOCTL_CFG80211) && RTW_P2P_GROUP_INTERFACE
./os_dep/linux/os_intfs.c:4486:				|| rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE)
./os_dep/linux/os_intfs.c:4489:			#endif /* CONFIG_P2P */
./os_dep/linux/os_intfs.c:4549:#ifdef CONFIG_P2P_WOWLAN
./os_dep/linux/os_intfs.c:4857:#ifdef CONFIG_P2P_WOWLAN
./os_dep/linux/os_intfs.c:4858:		if (!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE) || P2P_ROLE_DISABLE != padapter->wdinfo.role)
./os_dep/linux/os_intfs.c:4862:#endif /* CONFIG_P2P_WOWLAN */
./os_dep/linux/rtw_android.c:60:	"P2P_DEV_ADDR",
./os_dep/linux/rtw_android.c:65:	"P2P_SET_NOA",
./os_dep/linux/rtw_android.c:66:	"P2P_GET_NOA",
./os_dep/linux/rtw_android.c:67:	"P2P_SET_PS",
./os_dep/linux/rtw_android.c:68:	"SET_AP_WPS_P2P_IE",
./os_dep/linux/rtw_android.c:95:/*	Private command for	P2P disable*/
./os_dep/linux/rtw_android.c:96:	"P2P_DISABLE",
./os_dep/linux/rtw_android.c:814:	case ANDROID_WIFI_CMD_P2P_DEV_ADDR:
./os_dep/linux/rtw_android.c:817:	case ANDROID_WIFI_CMD_P2P_SET_NOA:
./os_dep/linux/rtw_android.c:818:		/* int skip = strlen(CMD_P2P_SET_NOA) + 1; */
./os_dep/linux/rtw_android.c:821:	case ANDROID_WIFI_CMD_P2P_GET_NOA:
./os_dep/linux/rtw_android.c:824:	case ANDROID_WIFI_CMD_P2P_SET_PS:
./os_dep/linux/rtw_android.c:825:		/* int skip = strlen(CMD_P2P_SET_PS) + 1; */
./os_dep/linux/rtw_android.c:830:	case ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE: {
./os_dep/linux/rtw_android.c:831:		int skip = strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE]) + 3;
./os_dep/linux/rtw_android.c:925:	case ANDROID_WIFI_CMD_P2P_DISABLE: {
./os_dep/linux/rtw_android.c:926:#ifdef CONFIG_P2P
./os_dep/linux/rtw_android.c:927:		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
./os_dep/linux/rtw_android.c:928:#endif /* CONFIG_P2P */
./os_dep/linux/rtw_cfgvendor.c:216:#define WIFI_FEATURE_P2P                0x0008      // Wifi-Direct
./os_dep/linux/rtw_cfgvendor.c:259:	feature_set |= WIFI_FEATURE_P2P;
./os_dep/linux/rtw_cfgvendor.c:314:		 /* Not yet verified NAN with P2P */
./os_dep/linux/rtw_cfgvendor.c:316:		 (feature_set_full & WIFI_FEATURE_P2P) |
./os_dep/linux/rtw_cfgvendor.h:405:    WIFI_INTERFACE_IBSS = 2,
./os_dep/linux/rtw_cfgvendor.h:406:    WIFI_INTERFACE_P2P_CLIENT = 3,
./os_dep/linux/rtw_cfgvendor.h:407:    WIFI_INTERFACE_P2P_GO = 4,
./os_dep/linux/rtw_cfgvendor.h:523:   WIFI_PEER_P2P_GO,
./os_dep/linux/rtw_cfgvendor.h:524:   WIFI_PEER_P2P_CLIENT,
./os_dep/linux/rtw_proc.c:4245:#ifdef CONFIG_P2P_WOWLAN
./os_dep/linux/sdio_intf.c:761:#ifdef CONFIG_P2P
./os_dep/linux/sdio_intf.c:763:#endif /* CONFIG_P2P */
./os_dep/linux/wifi_regd.c:57:		 NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
./os_dep/linux/wifi_regd.c:62:		 NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
./os_dep/linux/wifi_regd.c:67:		 NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
./os_dep/linux/wifi_regd.c:72:		 NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
./os_dep/linux/wifi_regd.c:185:				if (!(reg_rule->flags & NL80211_RRF_NO_IBSS))
./os_dep/linux/wifi_regd.c:186:					ch->flags &= ~IEEE80211_CHAN_NO_IBSS;
./os_dep/linux/wifi_regd.c:194:					ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
./os_dep/linux/wifi_regd.c:297:			ch->flags = (IEEE80211_CHAN_NO_IBSS | IEEE80211_CHAN_PASSIVE_SCAN);
./os_dep/linux/wifi_regd.c:312:			ch->flags |= (IEEE80211_CHAN_NO_IBSS | IEEE80211_CHAN_PASSIVE_SCAN);
